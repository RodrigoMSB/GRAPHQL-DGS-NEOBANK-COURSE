# =============================================================================
# INVESTMENT PORTFOLIO TRACKER - GraphQL Schema
# Capítulo 1: Fundamentos de GraphQL y Contexto Corporativo
# =============================================================================
#
# Este schema cubre las 5 secciones del capítulo:
# 1.1 - Comparación REST vs GraphQL
# 1.2 - Componentes base: Schema, Types, Queries, Mutations, Resolvers
# 1.3 - Consultas anidadas y variables
# 1.4 - Filtros, orden y paginación
# 1.5 - Tipado, nullabilidad y seguridad
# =============================================================================

# -----------------------------------------------------------------------------
# SECCIÓN 1.2 - TYPES (Tipos de datos)
# -----------------------------------------------------------------------------

"""
Representa un portfolio de inversión de un cliente.
Sección 1.2: Define la estructura de datos principal
Sección 1.5: Campos non-nullable marcados con !
"""
type Portfolio {
  """ID único del portfolio (non-nullable)"""
  id: ID!
  
  """Nombre del portfolio"""
  name: String!
  
  """ID del propietario del portfolio"""
  ownerId: String!
  
  """Nombre del propietario"""
  ownerName: String!
  
  """Valor total actual del portfolio en USD"""
  totalValue: Float!
  
  """Fecha de creación del portfolio"""
  createdAt: String!
  
  """
  Lista de activos en el portfolio
  Sección 1.3: Relación anidada - permite consultas como portfolio { assets { symbol } }
  """
  assets: [Asset!]!
  
  """
  Rendimiento histórico del portfolio
  Sección 1.3: Otra relación anidada
  """
  performance: Performance
}

"""
Representa un activo financiero dentro de un portfolio
"""
type Asset {
  """ID único del activo"""
  id: ID!
  
  """Símbolo del activo (ej: AAPL, GOOGL, BTC)"""
  symbol: String!
  
  """Nombre completo del activo"""
  name: String!
  
  """Tipo de activo"""
  assetType: AssetType!
  
  """Cantidad de unidades"""
  quantity: Float!
  
  """Precio de compra promedio"""
  averageBuyPrice: Float!
  
  """Precio actual del mercado"""
  currentPrice: Float!
  
  """Valor total del activo (quantity * currentPrice)"""
  totalValue: Float!
  
  """Ganancia/pérdida en porcentaje"""
  profitLossPercent: Float!
  
  """Fecha de última actualización"""
  lastUpdated: String!
}

"""
Enum para tipos de activos
Sección 1.2: Demuestra el uso de Enums en GraphQL
Sección 1.5: Validación automática - solo acepta estos valores
"""
enum AssetType {
  STOCK
  CRYPTO
  ETF
  BOND
  COMMODITY
}

"""
Representa el rendimiento histórico de un portfolio
"""
type Performance {
  """Rendimiento total desde creación (%)"""
  totalReturn: Float!
  
  """Rendimiento en el último año (%)"""
  yearReturn: Float!
  
  """Rendimiento en el último mes (%)"""
  monthReturn: Float!
  
  """Rendimiento en la última semana (%)"""
  weekReturn: Float!
  
  """Mejor activo del portfolio"""
  bestPerformer: Asset
  
  """Peor activo del portfolio"""
  worstPerformer: Asset
}

# -----------------------------------------------------------------------------
# SECCIÓN 1.4 - INPUTS (Para filtros y argumentos)
# -----------------------------------------------------------------------------

"""
Filtros para consultar activos
Sección 1.4: Permite filtrar por diferentes criterios
"""
input AssetFilterInput {
  """Filtrar por tipo de activo"""
  assetType: AssetType
  
  """Filtrar por valor mínimo"""
  minValue: Float
  
  """Filtrar por valor máximo"""
  maxValue: Float
  
  """Filtrar por símbolo (búsqueda parcial)"""
  symbolContains: String
}

"""
Opciones de ordenamiento para activos
Sección 1.4: Define cómo ordenar los resultados
"""
enum AssetSortField {
  SYMBOL
  TOTAL_VALUE
  PROFIT_LOSS_PERCENT
  QUANTITY
}

"""
Dirección del ordenamiento
"""
enum SortDirection {
  ASC
  DESC
}

"""
Input para ordenar activos
"""
input AssetSortInput {
  field: AssetSortField!
  direction: SortDirection!
}

"""
Input para paginación
Sección 1.4: Implementa cursor-based pagination
"""
input PaginationInput {
  """Número de elementos por página"""
  limit: Int = 10
  
  """Cursor para la siguiente página"""
  after: String
}

"""
Respuesta paginada de activos
Sección 1.4: Estructura estándar para paginación
"""
type AssetConnection {
  """Lista de activos en esta página"""
  edges: [AssetEdge!]!
  
  """Información de paginación"""
  pageInfo: PageInfo!
  
  """Total de elementos (opcional)"""
  totalCount: Int
}

"""
Edge de un activo (patrón Relay)
"""
type AssetEdge {
  """El activo"""
  node: Asset!
  
  """Cursor de este elemento"""
  cursor: String!
}

"""
Información de paginación
"""
type PageInfo {
  """¿Hay más páginas?"""
  hasNextPage: Boolean!
  
  """¿Hay páginas anteriores?"""
  hasPreviousPage: Boolean!
  
  """Cursor del primer elemento"""
  startCursor: String
  
  """Cursor del último elemento"""
  endCursor: String
}

# -----------------------------------------------------------------------------
# SECCIÓN 1.2 y 1.3 - QUERIES (Consultas)
# -----------------------------------------------------------------------------

type Query {
  """
  Obtiene todos los portfolios del usuario autenticado
  Sección 1.5: Requiere autenticación (se valida en el resolver)
  """
  myPortfolios: [Portfolio!]!
  
  """
  Obtiene un portfolio por ID
  Sección 1.3: Acepta variables - Ejemplo: query($id: ID!) { portfolio(id: $id) { name } }
  Sección 1.5: El ID es obligatorio (non-nullable)
  """
  portfolio(id: ID!): Portfolio
  
  """
  Obtiene todos los activos de un portfolio
  Sección 1.3: Consulta anidada - Puede usarse junto con portfolio
  Sección 1.4: Acepta filtros, ordenamiento y paginación
  """
  assets(
    portfolioId: ID!
    filter: AssetFilterInput
    sort: AssetSortInput
    pagination: PaginationInput
  ): AssetConnection!
  
  """
  Búsqueda de activos por símbolo
  Sección 1.3: Ejemplo de query simple con variable
  """
  searchAsset(symbol: String!): Asset
  
  """
  Obtiene el rendimiento de un portfolio
  Sección 1.3: Se puede anidar con portfolio { performance { totalReturn } }
  """
  portfolioPerformance(portfolioId: ID!): Performance
}

# -----------------------------------------------------------------------------
# SECCIÓN 1.2 - MUTATIONS (Modificaciones)
# -----------------------------------------------------------------------------

"""
Input para crear un nuevo portfolio
"""
input CreatePortfolioInput {
  name: String!
}

"""
Input para añadir un activo a un portfolio
"""
input AddAssetInput {
  portfolioId: ID!
  symbol: String!
  assetType: AssetType!
  quantity: Float!
  buyPrice: Float!
}

"""
Respuesta de una mutación (patrón común)
"""
type MutationResponse {
  """¿La operación fue exitosa?"""
  success: Boolean!
  
  """Mensaje descriptivo"""
  message: String!
  
  """Código de error (si aplica)"""
  code: String
}

"""
Respuesta al crear un portfolio
"""
type CreatePortfolioResponse {
  success: Boolean!
  message: String!
  portfolio: Portfolio
}

"""
Respuesta al añadir un activo
"""
type AddAssetResponse {
  success: Boolean!
  message: String!
  asset: Asset
}

type Mutation {
  """
  Crea un nuevo portfolio
  Sección 1.2: Demuestra mutations básicas
  Sección 1.5: Requiere autenticación
  """
  createPortfolio(input: CreatePortfolioInput!): CreatePortfolioResponse!
  
  """
  Añade un activo a un portfolio existente
  Sección 1.2: Mutation más compleja con múltiples argumentos
  """
  addAsset(input: AddAssetInput!): AddAssetResponse!
  
  """
  Elimina un activo de un portfolio
  Sección 1.2: Mutation de eliminación
  """
  removeAsset(portfolioId: ID!, assetId: ID!): MutationResponse!
}

# -----------------------------------------------------------------------------
# NOTAS PEDAGÓGICAS
# -----------------------------------------------------------------------------
#
# Este schema demuestra:
#
# ✅ Sección 1.1: Al comparar con REST, se ve cómo un solo endpoint GraphQL
#    reemplaza múltiples endpoints REST (/portfolios, /portfolios/:id/assets, etc.)
#
# ✅ Sección 1.2: Todos los componentes de GraphQL:
#    - Types (Portfolio, Asset, Performance)
#    - Queries (portfolio, assets, myPortfolios)
#    - Mutations (createPortfolio, addAsset, removeAsset)
#    - Enums (AssetType, SortDirection)
#    - Interfaces implícitas (MutationResponse)
#
# ✅ Sección 1.3: Consultas anidadas y variables:
#    - portfolio { assets { symbol } }
#    - query($id: ID!) { portfolio(id: $id) { ... } }
#
# ✅ Sección 1.4: Filtros, orden y paginación:
#    - AssetFilterInput para filtrar
#    - AssetSortInput para ordenar
#    - PaginationInput + AssetConnection para paginar
#
# ✅ Sección 1.5: Tipado y nullabilidad:
#    - Campos con ! son obligatorios
#    - Validación automática de tipos
#    - Autenticación se maneja en los resolvers (context)
#
# =============================================================================
