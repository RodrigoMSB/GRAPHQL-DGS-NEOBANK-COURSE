# =============================================================================
# INVESTMENT PORTFOLIO TRACKER - GraphQL Schema
# CapÃ­tulo 1: Fundamentos de GraphQL y Contexto Corporativo
# =============================================================================
#
# ðŸŽ¯ PROPÃ“SITO DE ESTE ARCHIVO:
# Este archivo es el CONTRATO de tu API GraphQL. Define:
# - QUÃ‰ datos existen (Types)
# - QUÃ‰ valores estÃ¡n permitidos (Enums)
# - QUÃ‰ puede enviar el cliente (Inputs)
# - QUÃ‰ puede LEER el cliente (Queries)
# - QUÃ‰ puede MODIFICAR el cliente (Mutations)
#
# ðŸ“š SECCIONES DEL CAPÃTULO QUE CUBRE:
# 1.1 - ComparaciÃ³n REST vs GraphQL
# 1.2 - Componentes base: Schema, Types, Queries, Mutations, Resolvers
# 1.3 - Consultas anidadas y variables
# 1.4 - Filtros, orden y paginaciÃ³n
# 1.5 - Tipado, nullabilidad y seguridad
#
# ðŸ—‚ï¸ ESTRUCTURA DE ESTE ARCHIVO (en orden pedagÃ³gico):
# 1. ENUMS      â†’ Valores permitidos (lÃ­nea ~30)
# 2. TYPES      â†’ Estructura de datos que RETORNA el servidor (lÃ­nea ~80)
# 3. INPUTS     â†’ Estructura de datos que ENVÃA el cliente (lÃ­nea ~230)
# 4. QUERIES    â†’ Operaciones de LECTURA (lÃ­nea ~300)
# 5. MUTATIONS  â†’ Operaciones de ESCRITURA (lÃ­nea ~360)
#
# =============================================================================


# =============================================================================
# 1. ENUMS - Valores Permitidos
# =============================================================================
#
# Los Enums definen un conjunto CERRADO de valores vÃ¡lidos.
# GraphQL valida automÃ¡ticamente que solo se usen estos valores.
#
# ðŸ’¡ ANALOGÃA: Es como un menÃº desplegable en un formulario web.
#    Solo puedes seleccionar las opciones que aparecen.
#
# =============================================================================

"""
Tipos de activos financieros soportados.

ðŸŽ“ SecciÃ³n 1.2: Demuestra el uso de Enums en GraphQL
ðŸŽ“ SecciÃ³n 1.5: ValidaciÃ³n automÃ¡tica - solo acepta estos valores

ðŸ’¡ EJEMPLO DE USO:
Si envÃ­as assetType: "INVALIDO", GraphQL rechaza la peticiÃ³n automÃ¡ticamente.
"""
enum AssetType {
  "Acciones de empresas (Apple, Google, etc.)"
  STOCK
  
  "Criptomonedas (Bitcoin, Ethereum, etc.)"
  CRYPTO
  
  "Fondos cotizados - Exchange Traded Funds"
  ETF
  
  "Bonos gubernamentales o corporativos"
  BOND
  
  "Materias primas (oro, plata, petrÃ³leo)"
  COMMODITY
}

"""
Campos disponibles para ordenar activos.

ðŸŽ“ SecciÃ³n 1.4: Se usa junto con SortDirection para ordenar resultados.
"""
enum AssetSortField {
  "Ordenar por sÃ­mbolo (alfabÃ©tico)"
  SYMBOL
  
  "Ordenar por valor total"
  TOTAL_VALUE
  
  "Ordenar por ganancia/pÃ©rdida porcentual"
  PROFIT_LOSS_PERCENT
  
  "Ordenar por cantidad de unidades"
  QUANTITY
}

"""
DirecciÃ³n del ordenamiento.
"""
enum SortDirection {
  "Ascendente (A-Z, 0-9, menor a mayor)"
  ASC
  
  "Descendente (Z-A, 9-0, mayor a menor)"
  DESC
}


# =============================================================================
# 2. TYPES - Estructura de Datos (lo que RETORNA el servidor)
# =============================================================================
#
# Los Types definen la FORMA de los datos que el servidor puede retornar.
# Son como las tablas de una base de datos, pero mÃ¡s flexibles.
#
# ðŸ’¡ ANALOGÃA: Si GraphQL fuera un restaurante, los Types serÃ­an
#    los PLATOS que el chef puede preparar.
#
# ðŸ”‘ NULLABILIDAD (SecciÃ³n 1.5):
#    - String  â†’ Puede ser null
#    - String! â†’ NUNCA puede ser null (obligatorio)
#    - [Item!]! â†’ Lista obligatoria con elementos obligatorios
#
# =============================================================================

# -----------------------------------------------------------------------------
# 2.1 TYPES DE DOMINIO (Entidades principales del negocio)
# -----------------------------------------------------------------------------

"""
Representa un portfolio de inversiÃ³n de un cliente.

ðŸŽ“ SecciÃ³n 1.2: Define la estructura de datos principal
ðŸŽ“ SecciÃ³n 1.3: Permite consultas anidadas (assets, performance)
ðŸŽ“ SecciÃ³n 1.5: Campos con ! son obligatorios (non-nullable)

ðŸ’¡ EJEMPLO DE CONSULTA ANIDADA:
```graphql
query {
  portfolio(id: "portfolio-001") {
    name
    totalValue
    assets {        â† AnidaciÃ³n nivel 1
      symbol
      currentPrice
    }
    performance {   â† AnidaciÃ³n nivel 1
      totalReturn
      bestPerformer {  â† AnidaciÃ³n nivel 2
        symbol
      }
    }
  }
}
```
"""
type Portfolio {
  "ID Ãºnico del portfolio - NUNCA es null"
  id: ID!
  
  "Nombre descriptivo del portfolio (ej: 'Retirement Fund')"
  name: String!
  
  "ID del usuario propietario"
  ownerId: String!
  
  "Nombre del usuario propietario"
  ownerName: String!
  
  "Valor total actual del portfolio en USD"
  totalValue: Float!
  
  "Fecha y hora de creaciÃ³n (formato ISO 8601)"
  createdAt: String!
  
  """
  Lista de activos en el portfolio.
  
  ðŸŽ“ SecciÃ³n 1.3: RelaciÃ³n anidada
  ðŸ’¡ Permite: portfolio { assets { symbol } }
  """
  assets: [Asset!]!
  
  """
  Rendimiento histÃ³rico del portfolio.
  
  ðŸŽ“ SecciÃ³n 1.3: RelaciÃ³n anidada opcional
  ðŸ’¡ Puede ser null si no hay suficientes datos histÃ³ricos
  """
  performance: Performance
}

"""
Representa un activo financiero dentro de un portfolio.

ðŸ’¡ CAMPOS CALCULADOS:
- totalValue: Se calcula como quantity * currentPrice
- profitLossPercent: Se calcula comparando currentPrice vs averageBuyPrice
"""
type Asset {
  "ID Ãºnico del activo"
  id: ID!
  
  "SÃ­mbolo bursÃ¡til (ej: AAPL, GOOGL, BTC)"
  symbol: String!
  
  "Nombre completo del activo (ej: 'Apple Inc.')"
  name: String!
  
  "Tipo de activo (STOCK, CRYPTO, ETF, BOND, COMMODITY)"
  assetType: AssetType!
  
  "Cantidad de unidades que posees"
  quantity: Float!
  
  "Precio promedio al que compraste"
  averageBuyPrice: Float!
  
  "Precio actual del mercado"
  currentPrice: Float!
  
  "Valor total = quantity Ã— currentPrice"
  totalValue: Float!
  
  "Ganancia o pÃ©rdida en porcentaje"
  profitLossPercent: Float!
  
  "Ãšltima vez que se actualizÃ³ el precio"
  lastUpdated: String!
}

"""
Representa el rendimiento histÃ³rico de un portfolio.

ðŸŽ“ SecciÃ³n 1.3: Se puede consultar anidado dentro de Portfolio
"""
type Performance {
  "Rendimiento total desde la creaciÃ³n (%)"
  totalReturn: Float!
  
  "Rendimiento en el Ãºltimo aÃ±o (%)"
  yearReturn: Float!
  
  "Rendimiento en el Ãºltimo mes (%)"
  monthReturn: Float!
  
  "Rendimiento en la Ãºltima semana (%)"
  weekReturn: Float!
  
  "Activo con mejor rendimiento (puede ser null si no hay activos)"
  bestPerformer: Asset
  
  "Activo con peor rendimiento (puede ser null si no hay activos)"
  worstPerformer: Asset
}

# -----------------------------------------------------------------------------
# 2.2 TYPES DE PAGINACIÃ“N (PatrÃ³n Relay/Connection)
# -----------------------------------------------------------------------------
#
# ðŸŽ“ SecciÃ³n 1.4: Implementa cursor-based pagination
#
# ðŸ’¡ Â¿POR QUÃ‰ CURSOR Y NO OFFSET?
# - Offset: "Dame los items 20-30" â†’ Problemas si se insertan/eliminan datos
# - Cursor: "Dame 10 items despuÃ©s de X" â†’ Siempre consistente
#
# ðŸ“¦ ESTRUCTURA:
# AssetConnection
# â”œâ”€â”€ edges[] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Lista de resultados
# â”‚   â”œâ”€â”€ node â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ El activo
# â”‚   â””â”€â”€ cursor â”€â”€â”€â”€â”€â”€â”€â”€ PosiciÃ³n Ãºnica de este item
# â”œâ”€â”€ pageInfo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Metadatos de paginaciÃ³n
# â”‚   â”œâ”€â”€ hasNextPage
# â”‚   â”œâ”€â”€ hasPreviousPage
# â”‚   â”œâ”€â”€ startCursor
# â”‚   â””â”€â”€ endCursor
# â””â”€â”€ totalCount â”€â”€â”€â”€â”€â”€â”€â”€ Total de elementos (opcional)
#
# -----------------------------------------------------------------------------

"""
Respuesta paginada de activos (PatrÃ³n Relay Connection).

ðŸŽ“ SecciÃ³n 1.4: Estructura estÃ¡ndar para paginaciÃ³n

ðŸ’¡ EJEMPLO DE USO:
```graphql
query {
  assets(portfolioId: "001", pagination: { limit: 5 }) {
    totalCount
    edges {
      cursor
      node { symbol }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```
"""
type AssetConnection {
  "Lista de activos en esta pÃ¡gina (cada uno con su cursor)"
  edges: [AssetEdge!]!
  
  "InformaciÃ³n para navegar entre pÃ¡ginas"
  pageInfo: PageInfo!
  
  "Total de elementos en toda la colecciÃ³n (Ãºtil para mostrar 'PÃ¡gina 1 de N')"
  totalCount: Int
}

"""
Envuelve un Asset con su cursor de paginaciÃ³n.

ðŸ’¡ El patrÃ³n Edge permite agregar metadatos por elemento
   sin contaminar el tipo original (Asset).
"""
type AssetEdge {
  "El activo en sÃ­"
  node: Asset!
  
  "Cursor Ãºnico para este elemento (usado para paginar)"
  cursor: String!
}

"""
Metadatos de paginaciÃ³n.
"""
type PageInfo {
  "Â¿Existen mÃ¡s elementos despuÃ©s de esta pÃ¡gina?"
  hasNextPage: Boolean!
  
  "Â¿Existen elementos antes de esta pÃ¡gina?"
  hasPreviousPage: Boolean!
  
  "Cursor del primer elemento de esta pÃ¡gina"
  startCursor: String
  
  "Cursor del Ãºltimo elemento de esta pÃ¡gina"
  endCursor: String
}

# -----------------------------------------------------------------------------
# 2.3 TYPES DE RESPUESTA (Para Mutations)
# -----------------------------------------------------------------------------
#
# ðŸ’¡ PATRÃ“N DE RESPUESTA:
# En vez de retornar solo el objeto creado, retornamos un objeto
# que incluye: success, message, y opcionalmente el objeto.
#
# Esto permite manejar errores de negocio de forma elegante.
#
# -----------------------------------------------------------------------------

"""
Respuesta genÃ©rica para mutations.

ðŸ’¡ PATRÃ“N: Siempre incluye success + message para feedback claro.
"""
type MutationResponse {
  "Â¿La operaciÃ³n fue exitosa?"
  success: Boolean!
  
  "Mensaje descriptivo (Ãºtil para mostrar al usuario)"
  message: String!
  
  "CÃ³digo de error/Ã©xito (Ãºtil para internacionalizaciÃ³n)"
  code: String
}

"""
Respuesta al crear un portfolio.
"""
type CreatePortfolioResponse {
  "Â¿Se creÃ³ exitosamente?"
  success: Boolean!
  
  "Mensaje descriptivo"
  message: String!
  
  "El portfolio creado (null si hubo error)"
  portfolio: Portfolio
}

"""
Respuesta al aÃ±adir un activo.
"""
type AddAssetResponse {
  "Â¿Se aÃ±adiÃ³ exitosamente?"
  success: Boolean!
  
  "Mensaje descriptivo"
  message: String!
  
  "El activo aÃ±adido (null si hubo error)"
  asset: Asset
}


# =============================================================================
# 3. INPUTS - Datos que ENVÃA el Cliente
# =============================================================================
#
# Los Inputs definen la FORMA de los datos que el cliente puede enviar.
# Son similares a los Types, pero solo para ENTRADA de datos.
#
# ðŸ’¡ ANALOGÃA: Si los Types son los platos del menÃº,
#    los Inputs son el FORMULARIO DE PEDIDO.
#
# ðŸ”‘ DIFERENCIA CLAVE:
#    - type  â†’ Lo que el servidor RETORNA (salida)
#    - input â†’ Lo que el cliente ENVÃA (entrada)
#
# =============================================================================

# -----------------------------------------------------------------------------
# 3.1 INPUTS PARA QUERIES (Filtros, Orden, PaginaciÃ³n)
# -----------------------------------------------------------------------------

"""
Filtros para consultar activos.

ðŸŽ“ SecciÃ³n 1.4: Permite filtrar por diferentes criterios

ðŸ’¡ EJEMPLO:
```graphql
query {
  assets(
    portfolioId: "001"
    filter: { assetType: STOCK, minValue: 1000 }
  ) { ... }
}
```

ðŸ’¡ TODOS LOS CAMPOS SON OPCIONALES:
Puedes usar uno, varios, o ninguno.
"""
input AssetFilterInput {
  "Filtrar por tipo de activo (STOCK, CRYPTO, etc.)"
  assetType: AssetType
  
  "Solo activos con valor >= minValue"
  minValue: Float
  
  "Solo activos con valor <= maxValue"
  maxValue: Float
  
  "Buscar sÃ­mbolos que contengan este texto (ej: 'AA' encuentra 'AAPL')"
  symbolContains: String
}

"""
Opciones de ordenamiento para activos.

ðŸŽ“ SecciÃ³n 1.4: Define cÃ³mo ordenar los resultados

ðŸ’¡ EJEMPLO:
```graphql
query {
  assets(
    portfolioId: "001"
    sort: { field: TOTAL_VALUE, direction: DESC }
  ) { ... }
}
```
"""
input AssetSortInput {
  "Campo por el cual ordenar"
  field: AssetSortField!
  
  "DirecciÃ³n del orden (ASC o DESC)"
  direction: SortDirection!
}

"""
Opciones de paginaciÃ³n.

ðŸŽ“ SecciÃ³n 1.4: Implementa cursor-based pagination

ðŸ’¡ EJEMPLO - Primera pÃ¡gina:
```graphql
query {
  assets(portfolioId: "001", pagination: { limit: 10 }) {
    edges { node { symbol } }
    pageInfo { endCursor hasNextPage }
  }
}
```

ðŸ’¡ EJEMPLO - Siguiente pÃ¡gina:
```graphql
query {
  assets(
    portfolioId: "001"
    pagination: { limit: 10, after: "cursor-del-ultimo-elemento" }
  ) { ... }
}
```
"""
input PaginationInput {
  "Cantidad de elementos por pÃ¡gina (default: 10)"
  limit: Int = 10
  
  "Cursor del elemento despuÃ©s del cual empezar (para paginaciÃ³n)"
  after: String
}

# -----------------------------------------------------------------------------
# 3.2 INPUTS PARA MUTATIONS (Crear, Modificar)
# -----------------------------------------------------------------------------

"""
Datos necesarios para crear un nuevo portfolio.

ðŸ’¡ EJEMPLO:
```graphql
mutation {
  createPortfolio(input: { name: "Mi Portfolio 2024" }) {
    success
    portfolio { id name }
  }
}
```
"""
input CreatePortfolioInput {
  "Nombre del nuevo portfolio (obligatorio)"
  name: String!
}

"""
Datos necesarios para aÃ±adir un activo a un portfolio.

ðŸ’¡ EJEMPLO:
```graphql
mutation {
  addAsset(input: {
    portfolioId: "portfolio-001"
    symbol: "TSLA"
    assetType: STOCK
    quantity: 10
    buyPrice: 250.00
  }) {
    success
    asset { id symbol totalValue }
  }
}
```
"""
input AddAssetInput {
  "ID del portfolio donde aÃ±adir el activo"
  portfolioId: ID!
  
  "SÃ­mbolo del activo (ej: AAPL, BTC)"
  symbol: String!
  
  "Tipo de activo"
  assetType: AssetType!
  
  "Cantidad de unidades a comprar"
  quantity: Float!
  
  "Precio de compra por unidad"
  buyPrice: Float!
}


# =============================================================================
# 4. QUERIES - Operaciones de LECTURA
# =============================================================================
#
# Las Queries son las operaciones para LEER datos.
# Equivalen a GET en REST.
#
# ðŸ’¡ ANALOGÃA: Son como PREGUNTAS que le haces al servidor.
#    "Â¿CuÃ¡les son mis portfolios?"
#    "Â¿CuÃ¡l es el portfolio con ID X?"
#
# ðŸ”‘ REGLA IMPORTANTE:
# Las queries NUNCA deben modificar datos. Solo lectura.
#
# =============================================================================

type Query {
  
  # ---------------------------------------------------------------------------
  # QUERIES DE PORTFOLIO
  # ---------------------------------------------------------------------------
  
  """
  Obtiene todos los portfolios del usuario autenticado.
  
  ðŸŽ“ SecciÃ³n 1.5: Requiere autenticaciÃ³n (se valida en el resolver)
  
  ðŸ’¡ EJEMPLO:
  ```graphql
  query {
    myPortfolios {
      id
      name
      totalValue
    }
  }
  ```
  
  ðŸ’¡ RETORNA: Lista SIEMPRE (nunca null, puede ser vacÃ­a [])
  """
  myPortfolios: [Portfolio!]!
  
  """
  Obtiene un portfolio especÃ­fico por su ID.
  
  ðŸŽ“ SecciÃ³n 1.3: Acepta variables
  ðŸŽ“ SecciÃ³n 1.5: El argumento ID es obligatorio (!)
  
  ðŸ’¡ EJEMPLO CON VARIABLE:
  ```graphql
  query GetPortfolio($id: ID!) {
    portfolio(id: $id) {
      name
      totalValue
      assets { symbol }
    }
  }
  
  # Variables: { "id": "portfolio-001" }
  ```
  
  ðŸ’¡ RETORNA: Portfolio o null (si no existe)
  """
  portfolio(id: ID!): Portfolio
  
  """
  Obtiene el rendimiento de un portfolio.
  
  ðŸŽ“ SecciÃ³n 1.3: TambiÃ©n accesible via: portfolio { performance { ... } }
  
  ðŸ’¡ EJEMPLO:
  ```graphql
  query {
    portfolioPerformance(portfolioId: "portfolio-001") {
      totalReturn
      bestPerformer { symbol }
    }
  }
  ```
  """
  portfolioPerformance(portfolioId: ID!): Performance
  
  # ---------------------------------------------------------------------------
  # QUERIES DE ASSETS
  # ---------------------------------------------------------------------------
  
  """
  Obtiene activos de un portfolio con filtros, orden y paginaciÃ³n.
  
  ðŸŽ“ SecciÃ³n 1.4: Demuestra filtros, ordenamiento y paginaciÃ³n
  
  ðŸ’¡ ARGUMENTOS:
  - portfolioId: OBLIGATORIO - Â¿De quÃ© portfolio?
  - filter: Opcional - Filtrar resultados
  - sort: Opcional - Ordenar resultados
  - pagination: Opcional - Paginar resultados
  
  ðŸ’¡ EJEMPLO COMPLETO:
  ```graphql
  query {
    assets(
      portfolioId: "portfolio-001"
      filter: { assetType: STOCK, minValue: 1000 }
      sort: { field: TOTAL_VALUE, direction: DESC }
      pagination: { limit: 5 }
    ) {
      totalCount
      edges {
        cursor
        node {
          symbol
          totalValue
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
  ```
  """
  assets(
    portfolioId: ID!
    filter: AssetFilterInput
    sort: AssetSortInput
    pagination: PaginationInput
  ): AssetConnection!
  
  """
  Busca un activo por su sÃ­mbolo bursÃ¡til.
  
  ðŸŽ“ SecciÃ³n 1.3: Query simple con variable
  
  ðŸ’¡ EJEMPLO:
  ```graphql
  query BuscarActivo($simbolo: String!) {
    searchAsset(symbol: $simbolo) {
      name
      currentPrice
      assetType
    }
  }
  
  # Variables: { "simbolo": "AAPL" }
  ```
  
  ðŸ’¡ RETORNA: Asset o null (si no existe)
  """
  searchAsset(symbol: String!): Asset
}


# =============================================================================
# 5. MUTATIONS - Operaciones de ESCRITURA
# =============================================================================
#
# Las Mutations son las operaciones para MODIFICAR datos.
# Equivalen a POST, PUT, DELETE en REST.
#
# ðŸ’¡ ANALOGÃA: Son como Ã“RDENES que le das al servidor.
#    "Crea un nuevo portfolio"
#    "AÃ±ade este activo"
#    "Elimina aquel activo"
#
# ðŸ”‘ PATRÃ“N DE RESPUESTA:
# Todas las mutations retornan un objeto con:
# - success: Boolean! â†’ Â¿FuncionÃ³?
# - message: String!  â†’ Â¿QuÃ© pasÃ³?
# - objeto: Type?     â†’ El objeto creado/modificado (si success=true)
#
# =============================================================================

type Mutation {
  
  """
  Crea un nuevo portfolio para el usuario autenticado.
  
  ðŸŽ“ SecciÃ³n 1.2: Mutation bÃ¡sica
  ðŸŽ“ SecciÃ³n 1.5: Requiere autenticaciÃ³n
  
  ðŸ’¡ EJEMPLO:
  ```graphql
  mutation {
    createPortfolio(input: { name: "Growth Portfolio 2024" }) {
      success
      message
      portfolio {
        id
        name
        createdAt
      }
    }
  }
  ```
  
  ðŸ’¡ EL CLIENTE DECIDE QUÃ‰ RETORNAR:
  Si solo necesitas el ID:
  ```graphql
  mutation {
    createPortfolio(input: { name: "Test" }) {
      success
      portfolio { id }
    }
  }
  ```
  """
  createPortfolio(input: CreatePortfolioInput!): CreatePortfolioResponse!
  
  """
  AÃ±ade un activo a un portfolio existente.
  
  ðŸŽ“ SecciÃ³n 1.2: Mutation con mÃºltiples campos en el input
  
  ðŸ’¡ EJEMPLO:
  ```graphql
  mutation AgregarActivo($input: AddAssetInput!) {
    addAsset(input: $input) {
      success
      message
      asset {
        id
        symbol
        totalValue
        profitLossPercent
      }
    }
  }
  
  # Variables:
  # {
  #   "input": {
  #     "portfolioId": "portfolio-001",
  #     "symbol": "NVDA",
  #     "assetType": "STOCK",
  #     "quantity": 15,
  #     "buyPrice": 450.00
  #   }
  # }
  ```
  """
  addAsset(input: AddAssetInput!): AddAssetResponse!
  
  """
  Elimina un activo de un portfolio.
  
  ðŸŽ“ SecciÃ³n 1.2: Mutation de eliminaciÃ³n
  
  ðŸ’¡ EJEMPLO:
  ```graphql
  mutation {
    removeAsset(
      portfolioId: "portfolio-001"
      assetId: "asset-003"
    ) {
      success
      message
      code
    }
  }
  ```
  
  ðŸ’¡ CÃ“DIGOS DE RESPUESTA:
  - code: "ASSET_REMOVED" â†’ Eliminado exitosamente
  - code: "ASSET_NOT_FOUND" â†’ No se encontrÃ³ el activo
  """
  removeAsset(portfolioId: ID!, assetId: ID!): MutationResponse!
}


# =============================================================================
# RESUMEN PEDAGÃ“GICO
# =============================================================================
#
# ðŸ“Š ESTADÃSTICAS DE ESTE SCHEMA:
# - 3 Enums (AssetType, AssetSortField, SortDirection)
# - 9 Types (Portfolio, Asset, Performance, AssetConnection, AssetEdge, 
#            PageInfo, MutationResponse, CreatePortfolioResponse, AddAssetResponse)
# - 5 Inputs (AssetFilterInput, AssetSortInput, PaginationInput,
#             CreatePortfolioInput, AddAssetInput)
# - 5 Queries (myPortfolios, portfolio, portfolioPerformance, assets, searchAsset)
# - 3 Mutations (createPortfolio, addAsset, removeAsset)
#
# ðŸŽ¯ CONCEPTOS DEMOSTRADOS:
#
# âœ… SecciÃ³n 1.1 - REST vs GraphQL:
#    Un solo endpoint GraphQL reemplaza mÃºltiples endpoints REST:
#    - GET /portfolios â†’ query { myPortfolios }
#    - GET /portfolios/:id â†’ query { portfolio(id: "...") }
#    - GET /portfolios/:id/assets â†’ query { portfolio(id: "...") { assets } }
#    - POST /portfolios â†’ mutation { createPortfolio }
#
# âœ… SecciÃ³n 1.2 - Componentes de GraphQL:
#    - Types: Portfolio, Asset, Performance
#    - Queries: myPortfolios, portfolio, searchAsset
#    - Mutations: createPortfolio, addAsset, removeAsset
#    - Enums: AssetType, SortDirection
#    - Inputs: CreatePortfolioInput, AddAssetInput
#
# âœ… SecciÃ³n 1.3 - Consultas anidadas y variables:
#    - AnidaciÃ³n: portfolio { assets { symbol } performance { totalReturn } }
#    - Variables: query($id: ID!) { portfolio(id: $id) { ... } }
#
# âœ… SecciÃ³n 1.4 - Filtros, orden y paginaciÃ³n:
#    - Filtros: AssetFilterInput
#    - Orden: AssetSortInput
#    - PaginaciÃ³n: PaginationInput + AssetConnection (patrÃ³n Relay)
#
# âœ… SecciÃ³n 1.5 - Tipado y nullabilidad:
#    - Campos obligatorios: ! (non-nullable)
#    - Listas: [Item!]! (lista y elementos obligatorios)
#    - ValidaciÃ³n automÃ¡tica de tipos
#
# =============================================================================
