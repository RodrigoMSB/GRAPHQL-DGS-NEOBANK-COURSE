# ==============================================================================
# CAPÃTULO 3: CASHBACK SERVICE CON NETFLIX DGS FRAMEWORK
# ==============================================================================
#
# ğŸ¯ TEMA: ImplementaciÃ³n completa de GraphQL con Netflix DGS + DataLoaders
#
# Este capÃ­tulo introduce:
# - Netflix DGS Framework (alternativa enterprise a Spring for GraphQL)
# - DataLoaders para resolver el problema N+1
# - Anotaciones @DgsComponent, @DgsQuery, @DgsMutation, @DgsData
# - Batch loading para queries eficientes
#
# ==============================================================================
# MAPEO COMPLETO: SCHEMA GRAPHQL â†” CLASES JAVA
# ==============================================================================
#
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚  SCHEMA GRAPHQL              â”‚  IMPLEMENTACIÃ“N JAVA                       â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  scalar Date                 â”‚  java.time.LocalDate (ScalarConfiguration) â”‚
# â”‚  scalar DateTime             â”‚  java.time.LocalDateTime                   â”‚
# â”‚  scalar Money                â”‚  java.math.BigDecimal                      â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  enum RewardStatus           â”‚  domain/RewardStatus.java                  â”‚
# â”‚  enum TransactionCategory    â”‚  domain/TransactionCategory.java           â”‚
# â”‚  enum RewardTier             â”‚  domain/RewardTier.java                    â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  type User                   â”‚  domain/User.java                          â”‚
# â”‚  type Reward                 â”‚  domain/Reward.java                        â”‚
# â”‚  type CashbackRule           â”‚  domain/CashbackRule.java                  â”‚
# â”‚  type TierMultipliers        â”‚  domain/TierMultipliers.java               â”‚
# â”‚  type RedemptionResult       â”‚  domain/RedemptionResult.java              â”‚
# â”‚  type RewardsSummary         â”‚  QueryDataFetcher.RewardsSummary (inner)   â”‚
# â”‚  type CategorySummary        â”‚  QueryDataFetcher.CategorySummary (inner)  â”‚
# â”‚  type StatusSummary          â”‚  QueryDataFetcher.StatusSummary (inner)    â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  input CreateRewardInput     â”‚  MutationDataFetcher.CreateRewardInput     â”‚
# â”‚  input RedeemCashbackInput   â”‚  MutationDataFetcher.RedeemCashbackInput   â”‚
# â”‚  input UpdateRewardStatusInputâ”‚ MutationDataFetcher.UpdateRewardStatus... â”‚
# â”‚  input RewardsFilterInput    â”‚  QueryDataFetcher.RewardsFilterInput       â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  Query.user                  â”‚  QueryDataFetcher.user() @DgsQuery         â”‚
# â”‚  Query.usersByTier           â”‚  QueryDataFetcher.usersByTier() @DgsQuery  â”‚
# â”‚  Query.reward                â”‚  QueryDataFetcher.reward() @DgsQuery       â”‚
# â”‚  Query.rewards               â”‚  QueryDataFetcher.rewards() @DgsQuery      â”‚
# â”‚  Query.userRewards           â”‚  QueryDataFetcher.userRewards() @DgsQuery  â”‚
# â”‚  Query.rewardsSummary        â”‚  QueryDataFetcher.rewardsSummary()         â”‚
# â”‚  Query.cashbackRules         â”‚  QueryDataFetcher.cashbackRules()          â”‚
# â”‚  Query.cashbackRule          â”‚  QueryDataFetcher.cashbackRule()           â”‚
# â”‚  Query.calculateCashback     â”‚  QueryDataFetcher.calculateCashback()      â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  Mutation.createReward       â”‚  MutationDataFetcher.createReward()        â”‚
# â”‚  Mutation.redeemCashback     â”‚  MutationDataFetcher.redeemCashback()      â”‚
# â”‚  Mutation.updateRewardStatus â”‚  MutationDataFetcher.updateRewardStatus()  â”‚
# â”‚  Mutation.expireOldRewards   â”‚  MutationDataFetcher.expireOldRewards()    â”‚
# â”‚  Mutation.upgradeUserTier    â”‚  MutationDataFetcher.upgradeUserTier()     â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  User.rewards                â”‚  NestedFieldDataFetcher.userRewards()      â”‚
# â”‚  Reward.user                 â”‚  NestedFieldDataFetcher.rewardUser()       â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚  DataLoader "users"          â”‚  dataloader/UserDataLoader.java            â”‚
# â”‚  DataLoader "rewards"        â”‚  dataloader/RewardsDataLoader.java         â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
# ==============================================================================
# ğŸ”¥ TEMA CENTRAL: EL PROBLEMA N+1 Y DATALOADERS
# ==============================================================================
#
# SIN DataLoader (problema N+1):
# ```
# query {
#   usersByTier(tier: GOLD) {  # Query 1: obtener 10 usuarios
#     fullName
#     rewards {                 # Queries 2-11: 10 queries individuales ğŸ˜±
#       amount
#     }
#   }
# }
# Total: 11 queries
# ```
#
# CON DataLoader (soluciÃ³n):
# ```
# query {
#   usersByTier(tier: GOLD) {  # Query 1: obtener 10 usuarios
#     fullName
#     rewards {                 # Query 2: 1 batch para TODAS las rewards ğŸš€
#       amount
#     }
#   }
# }
# Total: 2 queries
# ```
#
# ==============================================================================


# ==============================================================================
# CUSTOM SCALARS
# ==============================================================================
#
# ğŸ“ SECCIÃ“N 3.2: ConfiguraciÃ³n de escalares personalizados
#
# IMPLEMENTACIÃ“N: config/ScalarConfiguration.java
# ```java
# @Configuration
# public class ScalarConfiguration {
#     @Bean
#     public RuntimeWiringConfigurer runtimeWiringConfigurer() {
#         return builder -> builder
#             .scalar(ExtendedScalars.Date)
#             .scalar(ExtendedScalars.DateTime)
#             .scalar(moneyScalar());
#     }
# }
# ```
# ==============================================================================

"Fecha sin hora: 2025-11-15 â†’ java.time.LocalDate"
scalar Date

"Timestamp ISO-8601: 2025-11-15T10:30:00Z â†’ java.time.LocalDateTime"
scalar DateTime

"Dinero con precisiÃ³n decimal: 125.50 â†’ java.math.BigDecimal"
scalar Money


# ==============================================================================
# ENUMS
# ==============================================================================

"""
Estados de una recompensa cashback.

IMPLEMENTACIÃ“N JAVA: domain/RewardStatus.java
```java
public enum RewardStatus {
    PENDING,    // ReciÃ©n creada, pendiente validaciÃ³n
    ACTIVE,     // Disponible para usar
    EXPIRED,    // VenciÃ³ sin usar
    REDEEMED,   // Ya canjeada
    CANCELLED   // Cancelada por fraude/polÃ­ticas
}
```

CICLO DE VIDA:
```
PENDING â†’ ACTIVE â†’ REDEEMED (happy path)
                 â†’ EXPIRED (si no se usa)
        â†’ CANCELLED (fraude detectado)
```
"""
enum RewardStatus {
    PENDING
    ACTIVE
    EXPIRED
    REDEEMED
    CANCELLED
}

"""
CategorÃ­as de transacciones para cashback diferenciado.

IMPLEMENTACIÃ“N JAVA: domain/TransactionCategory.java
```java
public enum TransactionCategory {
    GROCERIES,        // Alto cashback
    RESTAURANTS,      // Medio-alto
    TRANSPORTATION,
    ENTERTAINMENT,
    SHOPPING,
    HEALTH,
    TRAVEL,           // Alto cashback
    UTILITIES,        // Bajo cashback
    EDUCATION,
    OTHER
}
```
"""
enum TransactionCategory {
    GROCERIES
    RESTAURANTS
    TRANSPORTATION
    ENTERTAINMENT
    SHOPPING
    HEALTH
    TRAVEL
    UTILITIES
    EDUCATION
    OTHER
}

"""
Niveles de membresÃ­a del programa de rewards.

IMPLEMENTACIÃ“N JAVA: domain/RewardTier.java
```java
public enum RewardTier {
    BRONZE,    // 1.0x multiplicador
    SILVER,    // 1.5x multiplicador
    GOLD,      // 2.0x multiplicador
    PLATINUM   // 3.0x multiplicador
}
```
"""
enum RewardTier {
    BRONZE
    SILVER
    GOLD
    PLATINUM
}


# ==============================================================================
# DOMAIN TYPES
# ==============================================================================

"""
Usuario del programa de cashback.

IMPLEMENTACIÃ“N JAVA: domain/User.java
```java
public class User {
    private String id;
    private String email;
    private String fullName;
    private RewardTier tier;
    private BigDecimal totalCashbackEarned;
    private BigDecimal availableCashback;
    private LocalDateTime createdAt;
}
```

CAMPO ANIDADO rewards:
- NO estÃ¡ en User.java (no tiene List<Reward>)
- Se resuelve con NestedFieldDataFetcher + DataLoader
```java
// NestedFieldDataFetcher.java
@DgsData(parentType = "User", field = "rewards")
public CompletableFuture<List<Reward>> userRewards(DgsDataFetchingEnvironment dfe) {
    User user = dfe.getSource();
    DataLoader<String, List<Reward>> dataLoader = dfe.getDataLoader("rewards");
    return dataLoader.load(user.getId());  // Batch loading!
}
```
"""
type User {
    id: ID!
    email: String!
    fullName: String!
    tier: RewardTier!
    totalCashbackEarned: Money!
    availableCashback: Money!
    createdAt: DateTime!
    
    """
    ğŸ”¥ CAMPO RESUELTO CON DATALOADER
    
    JAVA: NestedFieldDataFetcher.userRewards() + RewardsDataLoader
    
    En lugar de N queries individuales, usa batch loading:
    - Acumula todas las peticiones de rewards
    - Ejecuta UNA query batch
    - Distribuye resultados
    """
    rewards: [Reward!]!
}

"""
Recompensa cashback generada por una transacciÃ³n.

IMPLEMENTACIÃ“N JAVA: domain/Reward.java
```java
public class Reward {
    private String id;
    private String userId;           // FK - NO el objeto User
    private BigDecimal amount;
    private LocalDateTime earnedAt;
    private LocalDateTime expiresAt;
    private RewardStatus status;
    private TransactionCategory category;
    private String transactionId;
    private String description;
    private Double multiplier;
}
```

CAMPO ANIDADO user:
- Reward.java tiene userId (String), NO User
- Se resuelve con NestedFieldDataFetcher + DataLoader
```java
// NestedFieldDataFetcher.java
@DgsData(parentType = "Reward", field = "user")
public CompletableFuture<User> rewardUser(DgsDataFetchingEnvironment dfe) {
    Reward reward = dfe.getSource();
    DataLoader<String, User> dataLoader = dfe.getDataLoader("users");
    return dataLoader.load(reward.getUserId());  // Batch loading!
}
```
"""
type Reward {
    id: ID!
    userId: ID!
    
    """
    ğŸ”¥ CAMPO RESUELTO CON DATALOADER
    
    JAVA: NestedFieldDataFetcher.rewardUser() + UserDataLoader
    """
    user: User!
    
    amount: Money!
    earnedAt: DateTime!
    expiresAt: DateTime
    status: RewardStatus!
    category: TransactionCategory!
    transactionId: ID!
    description: String
    multiplier: Float!
}

"""
Regla de cashback por categorÃ­a.

IMPLEMENTACIÃ“N JAVA: domain/CashbackRule.java
```java
public class CashbackRule {
    private String id;
    private TransactionCategory category;
    private Double basePercentage;
    private TierMultipliers tierMultipliers;
    private BigDecimal minTransactionAmount;
    private BigDecimal maxCashbackPerTransaction;
    private Boolean isActive;
}
```
"""
type CashbackRule {
    id: ID!
    category: TransactionCategory!
    basePercentage: Float!
    tierMultipliers: TierMultipliers!
    minTransactionAmount: Money
    maxCashbackPerTransaction: Money
    isActive: Boolean!
}

"""
Multiplicadores de cashback por tier.

IMPLEMENTACIÃ“N JAVA: domain/TierMultipliers.java
```java
public class TierMultipliers {
    private Double bronze;   // 1.0
    private Double silver;   // 1.5
    private Double gold;     // 2.0
    private Double platinum; // 3.0
}
```

EJEMPLO DE CÃLCULO:
Usuario GOLD + CategorÃ­a GROCERIES (5% base):
cashback = monto Ã— 5% Ã— 2.0 = monto Ã— 10%
"""
type TierMultipliers {
    bronze: Float!
    silver: Float!
    gold: Float!
    platinum: Float!
}

"""
Resumen agregado de rewards de un usuario.

IMPLEMENTACIÃ“N JAVA: QueryDataFetcher (inner class)
```java
class RewardsSummary {
    private String userId;
    private BigDecimal totalEarned;
    private BigDecimal totalRedeemed;
    private BigDecimal totalExpired;
    private BigDecimal availableBalance;
    private List<CategorySummary> rewardsByCategory;
    private List<StatusSummary> rewardsByStatus;
}
```
"""
type RewardsSummary {
    userId: ID!
    totalEarned: Money!
    totalRedeemed: Money!
    totalExpired: Money!
    availableBalance: Money!
    rewardsByCategory: [CategorySummary!]!
    rewardsByStatus: [StatusSummary!]!
}

"""
Cashback agrupado por categorÃ­a.

IMPLEMENTACIÃ“N JAVA: QueryDataFetcher.CategorySummary (inner class)
"""
type CategorySummary {
    category: TransactionCategory!
    totalAmount: Money!
    count: Int!
}

"""
Cashback agrupado por estado.

IMPLEMENTACIÃ“N JAVA: QueryDataFetcher.StatusSummary (inner class)
"""
type StatusSummary {
    status: RewardStatus!
    totalAmount: Money!
    count: Int!
}

"""
Resultado de redenciÃ³n de cashback.

IMPLEMENTACIÃ“N JAVA: domain/RedemptionResult.java
```java
public class RedemptionResult {
    private Boolean success;
    private String message;
    private BigDecimal redeemedAmount;
    private BigDecimal newBalance;
    private String transactionId;
}
```
"""
type RedemptionResult {
    success: Boolean!
    message: String!
    redeemedAmount: Money
    newBalance: Money
    transactionId: ID
}


# ==============================================================================
# INPUT TYPES
# ==============================================================================

"""
Input para crear una reward.

IMPLEMENTACIÃ“N JAVA: MutationDataFetcher.CreateRewardInput (inner class)
```java
class CreateRewardInput {
    private String userId;
    private String transactionId;
    private BigDecimal transactionAmount;
    private TransactionCategory category;
    private String description;
}
```
"""
input CreateRewardInput {
    userId: ID!
    transactionId: ID!
    transactionAmount: Money!
    category: TransactionCategory!
    description: String
}

"""
Input para canjear cashback.

IMPLEMENTACIÃ“N JAVA: MutationDataFetcher.RedeemCashbackInput (inner class)
```java
class RedeemCashbackInput {
    private String userId;
    private BigDecimal amount;
    private String destinationAccount;
}
```
"""
input RedeemCashbackInput {
    userId: ID!
    amount: Money!
    destinationAccount: String!
}

"""
Input para actualizar estado de reward.

IMPLEMENTACIÃ“N JAVA: MutationDataFetcher.UpdateRewardStatusInput (inner class)
```java
class UpdateRewardStatusInput {
    private String rewardId;
    private RewardStatus newStatus;
    private String reason;
}
```
"""
input UpdateRewardStatusInput {
    rewardId: ID!
    newStatus: RewardStatus!
    reason: String
}

"""
Filtros para buscar rewards.

IMPLEMENTACIÃ“N JAVA: QueryDataFetcher.RewardsFilterInput (inner class)
```java
class RewardsFilterInput {
    private String userId;
    private RewardStatus status;
    private TransactionCategory category;
    private BigDecimal minAmount;
    private BigDecimal maxAmount;
    private LocalDateTime earnedAfter;
    private LocalDateTime earnedBefore;
}
```
"""
input RewardsFilterInput {
    userId: ID
    status: RewardStatus
    category: TransactionCategory
    minAmount: Money
    maxAmount: Money
    earnedAfter: DateTime
    earnedBefore: DateTime
}


# ==============================================================================
# QUERIES
# ==============================================================================
#
# ğŸ“ SECCIÃ“N 3.3: ImplementaciÃ³n de queries con @DgsQuery
#
# IMPLEMENTACIÃ“N: datafetcher/QueryDataFetcher.java
# ```java
# @DgsComponent
# public class QueryDataFetcher {
#     @DgsQuery
#     public User user(@InputArgument String id) { ... }
# }
# ```
# ==============================================================================

type Query {
    
    """
    Obtener usuario por ID.
    
    JAVA: QueryDataFetcher.user()
```java
    @DgsQuery
    public User user(@InputArgument String id) {
        return userRepository.findById(id).orElse(null);
    }
```
    """
    user(id: ID!): User
    
    """
    Filtrar usuarios por tier.
    
    JAVA: QueryDataFetcher.usersByTier()
```java
    @DgsQuery
    public List<User> usersByTier(@InputArgument RewardTier tier) {
        return userRepository.findByTier(tier);
    }
```
    
    ğŸ’¡ EJEMPLO CON DATALOADER:
```graphql
    query {
      usersByTier(tier: GOLD) {
        fullName
        rewards {        # â† Usa RewardsDataLoader (1 batch query)
          amount
          user {         # â† Usa UserDataLoader (1 batch query)
            email
          }
        }
      }
    }
    # Total: 3 queries en lugar de N+1
```
    """
    usersByTier(tier: RewardTier!): [User!]!
    
    """
    Obtener reward por ID.
    
    JAVA: QueryDataFetcher.reward()
```java
    @DgsQuery
    public Reward reward(@InputArgument String id) {
        return rewardRepository.findById(id).orElse(null);
    }
```
    """
    reward(id: ID!): Reward
    
    """
    Listar rewards con filtros complejos.
    
    JAVA: QueryDataFetcher.rewards()
```java
    @DgsQuery
    public List<Reward> rewards(@InputArgument RewardsFilterInput filter) {
        List<Reward> allRewards = rewardRepository.findAll();
        if (filter == null) return allRewards;
        
        return allRewards.stream()
            .filter(r -> filter.getUserId() == null || 
                         r.getUserId().equals(filter.getUserId()))
            .filter(r -> filter.getStatus() == null || 
                         r.getStatus() == filter.getStatus())
            // ... mÃ¡s filtros
            .collect(Collectors.toList());
    }
```
    """
    rewards(filter: RewardsFilterInput): [Reward!]!
    
    """
    Rewards de un usuario con filtro opcional de estado.
    
    JAVA: QueryDataFetcher.userRewards()
```java
    @DgsQuery
    public List<Reward> userRewards(
            @InputArgument String userId,
            @InputArgument(name = "status") RewardStatus rewardStatus) {
        if (rewardStatus != null) {
            return rewardRepository.findByUserIdAndStatus(userId, rewardStatus);
        }
        return rewardRepository.findByUserId(userId);
    }
```
    """
    userRewards(userId: ID!, status: RewardStatus): [Reward!]!
    
    """
    Resumen agregado de rewards de un usuario.
    
    JAVA: QueryDataFetcher.rewardsSummary()
    - Calcula totalEarned, totalRedeemed, totalExpired
    - Agrupa por categorÃ­a y estado
    """
    rewardsSummary(userId: ID!): RewardsSummary
    
    """
    Listar todas las reglas de cashback.
    
    JAVA: QueryDataFetcher.cashbackRules()
```java
    @DgsQuery
    public List<CashbackRule> cashbackRules() {
        return ruleRepository.findAll();
    }
```
    """
    cashbackRules: [CashbackRule!]!
    
    """
    Obtener regla de una categorÃ­a especÃ­fica.
    
    JAVA: QueryDataFetcher.cashbackRule()
```java
    @DgsQuery
    public CashbackRule cashbackRule(@InputArgument TransactionCategory category) {
        return ruleRepository.findByCategory(category).orElse(null);
    }
```
    """
    cashbackRule(category: TransactionCategory!): CashbackRule
    
    """
    Calcular cashback estimado para una transacciÃ³n hipotÃ©tica.
    
    JAVA: QueryDataFetcher.calculateCashback()
```java
    @DgsQuery
    public BigDecimal calculateCashback(
            @InputArgument String userId,
            @InputArgument BigDecimal transactionAmount,
            @InputArgument TransactionCategory category) {
        return cashbackService.calculateCashback(userId, transactionAmount, category);
    }
```
    
    ğŸ’¡ ÃšTIL PARA:
    Mostrar al usuario cuÃ¡nto ganarÃ¡ ANTES de hacer la compra.
    """
    calculateCashback(
        userId: ID!
        transactionAmount: Money!
        category: TransactionCategory!
    ): Money!
}


# ==============================================================================
# MUTATIONS
# ==============================================================================
#
# ğŸ“ SECCIÃ“N 3.4: ImplementaciÃ³n de mutations con @DgsMutation
#
# IMPLEMENTACIÃ“N: datafetcher/MutationDataFetcher.java
# ```java
# @DgsComponent
# public class MutationDataFetcher {
#     @DgsMutation
#     public Reward createReward(@InputArgument CreateRewardInput input) { ... }
# }
# ```
# ==============================================================================

type Mutation {
    
    """
    Crear reward basada en una transacciÃ³n.
    
    JAVA: MutationDataFetcher.createReward()
```java
    @DgsMutation
    public Reward createReward(@InputArgument CreateRewardInput input) {
        return cashbackService.createReward(
            input.getUserId(),
            input.getTransactionId(),
            input.getTransactionAmount(),
            input.getCategory(),
            input.getDescription()
        );
    }
```
    
    ğŸ’¡ FLUJO TÃPICO:
    1. Usuario hace compra con tarjeta NeoBank
    2. Sistema emite evento TRANSACTION_COMPLETED
    3. Cashback Service ejecuta esta mutation
    4. Se crea reward y acredita al usuario
    """
    createReward(input: CreateRewardInput!): Reward!
    
    """
    Canjear cashback disponible.
    
    JAVA: MutationDataFetcher.redeemCashback()
```java
    @DgsMutation
    public RedemptionResult redeemCashback(@InputArgument RedeemCashbackInput input) {
        return cashbackService.redeemCashback(
            input.getUserId(),
            input.getAmount(),
            input.getDestinationAccount()
        );
    }
```
    
    ğŸ’¡ MÃ‰TODOS DE REDENCIÃ“N:
    - Transferencia a cuenta bancaria
    - Pago de tarjeta de crÃ©dito
    - CrÃ©dito en cuenta
    """
    redeemCashback(input: RedeemCashbackInput!): RedemptionResult!
    
    """
    Actualizar estado de una reward (admin).
    
    JAVA: MutationDataFetcher.updateRewardStatus()
```java
    @DgsMutation
    public Reward updateRewardStatus(@InputArgument UpdateRewardStatusInput input) {
        return cashbackService.updateRewardStatus(
            input.getRewardId(),
            input.getNewStatus(),
            input.getReason()
        );
    }
```
    
    ğŸ’¡ CASOS DE USO:
    - Cancelar por fraude detectado
    - Marcar como expirada
    - Reversiones por devoluciones
    """
    updateRewardStatus(input: UpdateRewardStatusInput!): Reward!
    
    """
    Job batch para expirar rewards vencidas.
    
    JAVA: MutationDataFetcher.expireOldRewards()
```java
    @DgsMutation
    public Integer expireOldRewards() {
        return cashbackService.expireOldRewards();
    }
```
    
    ğŸ’¡ EJECUCIÃ“N TÃPICA:
    - Via cron job diario
    - Via @Scheduled de Spring
    - Manualmente por admin
    
    Retorna cantidad de rewards expiradas.
    """
    expireOldRewards: Int!
    
    """
    Promocionar usuario a tier superior.
    
    JAVA: MutationDataFetcher.upgradeUserTier()
```java
    @DgsMutation
    public User upgradeUserTier(
            @InputArgument String userId,
            @InputArgument RewardTier newTier) {
        return cashbackService.upgradeUserTier(userId, newTier);
    }
```
    
    ğŸ’¡ CRITERIOS DE UPGRADE:
    - Total cashback ganado
    - NÃºmero de transacciones
    - Monto total gastado
    - Promociones especiales
    """
    upgradeUserTier(userId: ID!, newTier: RewardTier!): User!
}


# ==============================================================================
# ğŸ”¥ DATALOADERS - LA MAGIA DETRÃS DE ESCENAS
# ==============================================================================
#
# Los DataLoaders NO aparecen en el schema GraphQL, pero son CRÃTICOS
# para el rendimiento. Resuelven campos anidados de forma eficiente.
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# USERDATALOADER: Carga usuarios en batch
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# ARCHIVO: dataloader/UserDataLoader.java
#
# ```java
# @DgsDataLoader(name = "users")
# public class UserDataLoader implements BatchLoader<String, User> {
#     
#     @Override
#     public CompletionStage<List<User>> load(List<String> userIds) {
#         System.out.println("ğŸ”¥ Batch loading " + userIds.size() + " users");
#         
#         // 1 query para TODOS los usuarios solicitados
#         List<User> allUsers = userRepository.findAll();
#         
#         // Crear mapa para lookup eficiente
#         Map<String, User> userMap = allUsers.stream()
#             .filter(user -> userIds.contains(user.getId()))
#             .collect(Collectors.toMap(User::getId, user -> user));
#         
#         // CRÃTICO: Devolver en el MISMO ORDEN que las keys
#         List<User> result = userIds.stream()
#             .map(userMap::get)
#             .collect(Collectors.toList());
#         
#         return CompletableFuture.completedFuture(result);
#     }
# }
# ```
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# REWARDSDATALOADER: Carga rewards por usuario en batch
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# ARCHIVO: dataloader/RewardsDataLoader.java
#
# ```java
# @DgsDataLoader(name = "rewards")
# public class RewardsDataLoader implements BatchLoader<String, List<Reward>> {
#     
#     @Override
#     public CompletionStage<List<List<Reward>>> load(List<String> userIds) {
#         System.out.println("ğŸ”¥ Batch loading rewards for " + userIds.size() + " users");
#         
#         // 1 query para TODAS las rewards
#         List<Reward> allRewards = rewardRepository.findAll();
#         
#         // Agrupar por userId
#         Map<String, List<Reward>> rewardsByUser = allRewards.stream()
#             .filter(r -> userIds.contains(r.getUserId()))
#             .collect(Collectors.groupingBy(Reward::getUserId));
#         
#         // CRÃTICO: Devolver lista vacÃ­a (NO null) si usuario no tiene rewards
#         List<List<Reward>> result = userIds.stream()
#             .map(userId -> rewardsByUser.getOrDefault(userId, List.of()))
#             .collect(Collectors.toList());
#         
#         return CompletableFuture.completedFuture(result);
#     }
# }
# ```
#
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DIFERENCIA CLAVE:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# UserDataLoader:    BatchLoader<String, User>          â†’ UN User por key
# RewardsDataLoader: BatchLoader<String, List<Reward>>  â†’ LISTA por key
#
# Para relaciones 1:N (User â†’ Rewards), usa List<V>
# Para relaciones N:1 (Reward â†’ User), usa V
#
# ==============================================================================


# ==============================================================================
# RESUMEN: ARCHIVOS JAVA DEL CAPÃTULO 3
# ==============================================================================
#
# ğŸ“¦ DOMAIN (domain/):
# â”œâ”€â”€ User.java                    â†’ type User (sin rewards)
# â”œâ”€â”€ Reward.java                  â†’ type Reward (con userId, sin user)
# â”œâ”€â”€ CashbackRule.java            â†’ type CashbackRule
# â”œâ”€â”€ TierMultipliers.java         â†’ type TierMultipliers
# â”œâ”€â”€ RedemptionResult.java        â†’ type RedemptionResult
# â”œâ”€â”€ RewardStatus.java            â†’ enum RewardStatus
# â”œâ”€â”€ RewardTier.java              â†’ enum RewardTier
# â””â”€â”€ TransactionCategory.java     â†’ enum TransactionCategory
#
# ğŸ“¦ DATAFETCHERS (datafetcher/):
# â”œâ”€â”€ QueryDataFetcher.java        â†’ Todas las @DgsQuery
# â”‚   â””â”€â”€ Inner classes: RewardsFilterInput, RewardsSummary, 
# â”‚                      CategorySummary, StatusSummary
# â”œâ”€â”€ MutationDataFetcher.java     â†’ Todas las @DgsMutation
# â”‚   â””â”€â”€ Inner classes: CreateRewardInput, RedeemCashbackInput,
# â”‚                      UpdateRewardStatusInput
# â””â”€â”€ NestedFieldDataFetcher.java  â†’ @DgsData para User.rewards, Reward.user
#
# ğŸ“¦ DATALOADERS (dataloader/):
# â”œâ”€â”€ UserDataLoader.java          â†’ BatchLoader<String, User>
# â””â”€â”€ RewardsDataLoader.java       â†’ BatchLoader<String, List<Reward>>
#
# ğŸ“¦ CONFIG (config/):
# â””â”€â”€ ScalarConfiguration.java     â†’ Registro de scalars Date, DateTime, Money
#
# ğŸ“¦ REPOSITORIES (repository/):
# â”œâ”€â”€ UserRepository.java          â†’ Acceso a datos de usuarios
# â”œâ”€â”€ RewardRepository.java        â†’ Acceso a datos de rewards
# â””â”€â”€ CashbackRuleRepository.java  â†’ Acceso a reglas de cashback
#
# ğŸ“¦ SERVICE (service/):
# â””â”€â”€ CashbackService.java         â†’ LÃ³gica de negocio de cashback
#
# ==============================================================================
#
# ğŸ¯ ANOTACIONES DGS USADAS:
#
# @DgsComponent      â†’ Marca clase como componente DGS (similar a @Component)
# @DgsQuery          â†’ MÃ©todo resuelve una Query del schema
# @DgsMutation       â†’ MÃ©todo resuelve una Mutation del schema
# @DgsData           â†’ MÃ©todo resuelve un campo especÃ­fico de un type
# @DgsDataLoader     â†’ Registra un BatchLoader para optimizaciÃ³n N+1
# @InputArgument     â†’ Inyecta argumento de la query/mutation
#
# ==============================================================================