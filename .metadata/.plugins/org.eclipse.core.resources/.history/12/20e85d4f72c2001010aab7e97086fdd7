#!/bin/bash

################################################################################
# CHAPTER 01: FUNDAMENTOS DE GRAPHQL Y CONTEXTO CORPORATIVO
# Script de Testing Automatizado
#
# Este script prueba TODAS las funcionalidades del Cap√≠tulo 1:
# - Secci√≥n 1.1: REST vs GraphQL
# - Secci√≥n 1.2: Componentes base (Schema, Types, Queries, Mutations, Resolvers)
# - Secci√≥n 1.3: Consultas anidadas y variables
# - Secci√≥n 1.4: Filtros, orden y paginaci√≥n
# - Secci√≥n 1.5: Tipado, nullabilidad y seguridad
#
# Uso: ./test-chapter01.sh
################################################################################

# Colores para output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuraci√≥n
BASE_URL="http://localhost:8080"
GRAPHQL_ENDPOINT="${BASE_URL}/graphql"
REST_ENDPOINT="${BASE_URL}/api/rest"

# Contadores
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Funci√≥n para imprimir headers de secci√≥n
print_section() {
    echo ""
    echo -e "${CYAN}================================================================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}================================================================================${NC}"
    echo ""
}

# Funci√≥n para imprimir sub-secci√≥n
print_subsection() {
    echo ""
    echo -e "${BLUE}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
}

# Funci√≥n para ejecutar test
run_test() {
    local test_name="$1"
    local curl_command="$2"
    local validation="$3"
    
    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    
    echo -e "${YELLOW}üß™ Test #${TOTAL_TESTS}: ${test_name}${NC}"
    echo -e "   Ejecutando..."
    
    # Ejecutar curl y capturar respuesta
    response=$(eval "$curl_command" 2>&1)
    exit_code=$?
    
    # Mostrar respuesta (truncada si es muy larga)
    if [ ${#response} -gt 200 ]; then
        echo -e "   üìÑ Respuesta: ${response:0:200}..."
    else
        echo -e "   üìÑ Respuesta: $response"
    fi
    
    # Validar respuesta
    if [ $exit_code -eq 0 ] && echo "$response" | grep -q "$validation"; then
        echo -e "   ${GREEN}‚úÖ PASSED${NC}"
        PASSED_TESTS=$((PASSED_TESTS + 1))
    else
        echo -e "   ${RED}‚ùå FAILED${NC}"
        FAILED_TESTS=$((FAILED_TESTS + 1))
    fi
    
    echo ""
    sleep 1
}

# Funci√≥n para ejecutar test GraphQL
run_graphql_test() {
    local test_name="$1"
    local query="$2"
    local validation="$3"
    
    local curl_cmd="curl -s -X POST ${GRAPHQL_ENDPOINT} -H 'Content-Type: application/json' -d '{\"query\": \"$query\"}'"
    run_test "$test_name" "$curl_cmd" "$validation"
}

# Verificar que el servidor est√© corriendo
echo -e "${YELLOW}üîç Verificando que el servidor est√© corriendo...${NC}"
if ! curl -s "${BASE_URL}" > /dev/null 2>&1; then
    echo -e "${RED}‚ùå ERROR: El servidor no est√° corriendo en ${BASE_URL}${NC}"
    echo -e "${YELLOW}üí° Por favor inicia el servidor con: mvn spring-boot:run${NC}"
    exit 1
fi
echo -e "${GREEN}‚úÖ Servidor detectado${NC}"
echo ""

################################################################################
# SECCI√ìN 1.1 - DE REST A GRAPHQL
################################################################################
print_section "SECCI√ìN 1.1 ‚Äî DE REST A GRAPHQL (30 min)"
echo "Objetivo: Comparar REST vs GraphQL y demostrar overfetching/underfetching"

print_subsection "1.1.1 - REST: Overfetching (recibir m√°s datos de los necesarios)"
run_test \
    "REST - Obtener portfolios (devuelve TODO incluyendo assets y performance)" \
    "curl -s ${REST_ENDPOINT}/portfolios" \
    '"assets".*"performance"'

print_subsection "1.1.2 - GraphQL: Solicitar solo lo necesario"
run_graphql_test \
    "GraphQL - Obtener solo nombres de portfolios (sin overfetching)" \
    "{ myPortfolios { name } }" \
    '"name"'

print_subsection "1.1.3 - REST: Underfetching (m√∫ltiples llamadas necesarias)"
echo -e "${YELLOW}üìù En REST necesitar√≠as 3 llamadas HTTP para obtener portfolio + assets + performance${NC}"
run_test \
    "REST - Llamada 1: Obtener portfolio" \
    "curl -s ${REST_ENDPOINT}/portfolios/portfolio-001" \
    '"id":"portfolio-001"'

run_test \
    "REST - Llamada 2: Obtener assets del portfolio" \
    "curl -s ${REST_ENDPOINT}/portfolios/portfolio-001/assets" \
    '"symbol"'

run_test \
    "REST - Llamada 3: Obtener performance del portfolio" \
    "curl -s ${REST_ENDPOINT}/portfolios/portfolio-001/performance" \
    '"totalReturn"'

print_subsection "1.1.4 - GraphQL: Una sola llamada (sin underfetching)"
run_graphql_test \
    "GraphQL - TODO en UNA sola query (portfolio + assets + performance)" \
    "{ portfolio(id: \\\"portfolio-001\\\") { name totalValue assets { symbol } performance { totalReturn } } }" \
    '"portfolio".*"assets".*"performance"'

print_subsection "1.1.5 - Endpoint √∫nico de GraphQL"
echo -e "${YELLOW}üìù GraphQL usa UN solo endpoint (/graphql) vs m√∫ltiples en REST${NC}"
run_graphql_test \
    "GraphQL - Endpoint √∫nico para cualquier query" \
    "{ myPortfolios { id } }" \
    '"myPortfolios"'

################################################################################
# SECCI√ìN 1.2 - COMPONENTES Y LENGUAJE BASE
################################################################################
print_section "SECCI√ìN 1.2 ‚Äî COMPONENTES Y LENGUAJE BASE (30 min)"
echo "Objetivo: Schema, Types, Queries, Mutations, Resolvers"

print_subsection "1.2.1 - Schema como contrato: Types"
run_graphql_test \
    "Query retorna tipos definidos en el schema (Portfolio type)" \
    "{ portfolio(id: \\\"portfolio-001\\\") { id name totalValue } }" \
    '"id".*"name".*"totalValue"'

print_subsection "1.2.2 - Queries: Recuperar datos"
run_graphql_test \
    "Query simple: myPortfolios" \
    "{ myPortfolios { id name } }" \
    '"myPortfolios"'

run_graphql_test \
    "Query con argumento: portfolio(id)" \
    "{ portfolio(id: \\\"portfolio-001\\\") { name } }" \
    '"Growth Portfolio"'

run_graphql_test \
    "Query de b√∫squeda: searchAsset" \
    "{ searchAsset(symbol: \\\"AAPL\\\") { name currentPrice } }" \
    '"Apple Inc"'

print_subsection "1.2.3 - Mutations: Modificar datos"
run_graphql_test \
    "Mutation: Crear portfolio" \
    "mutation { createPortfolio(input: {name: \\\"Test Portfolio\\\"}) { success message portfolio { id name totalValue } } }" \
    '"success":true'

# Capturar el ID del portfolio creado para usarlo en la siguiente mutation
CREATED_PORTFOLIO_ID=$(curl -s -X POST ${GRAPHQL_ENDPOINT} -H 'Content-Type: application/json' \
    -d '{"query": "mutation { createPortfolio(input: {name: \"Temp Portfolio\"}) { portfolio { id } } }"}' \
    | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4)

if [ -n "$CREATED_PORTFOLIO_ID" ]; then
    run_graphql_test \
        "Mutation: A√±adir asset al portfolio creado" \
        "mutation { addAsset(input: {portfolioId: \\\"${CREATED_PORTFOLIO_ID}\\\", symbol: \\\"NVDA\\\", assetType: STOCK, quantity: 10, buyPrice: 500}) { success asset { symbol totalValue } } }" \
        '"success":true'
fi

run_graphql_test \
    "Mutation: Eliminar asset (operaci√≥n de escritura)" \
    "mutation { removeAsset(portfolioId: \\\"portfolio-001\\\", assetId: \\\"asset-999\\\") { success message } }" \
    '"success"'

print_subsection "1.2.4 - Enums: Validaci√≥n de tipos"
run_graphql_test \
    "Enum AssetType en acci√≥n (STOCK, CRYPTO, ETF, etc.)" \
    "{ portfolio(id: \\\"portfolio-001\\\") { assets { symbol assetType } } }" \
    '"assetType"'

print_subsection "1.2.5 - Resolvers: L√≥gica de conexi√≥n"
echo -e "${YELLOW}üìù Los resolvers conectan las queries con los datos (MockDataService)${NC}"
run_graphql_test \
    "Resolver obtiene datos del servicio y los retorna seg√∫n el schema" \
    "{ myPortfolios { name ownerName } }" \
    '"Carlos Mendoza"'

################################################################################
# SECCI√ìN 1.3 - CONSULTAS ANIDADAS Y VARIABLES
################################################################################
print_section "SECCI√ìN 1.3 ‚Äî CONSULTAS ANIDADAS Y USO DE VARIABLES (30 min)"
echo "Objetivo: Anidaci√≥n de entidades y uso de variables parametrizadas"

print_subsection "1.3.1 - Consultas anidadas nivel 1"
run_graphql_test \
    "Portfolio con assets anidados" \
    "{ portfolio(id: \\\"portfolio-001\\\") { name assets { symbol currentPrice } } }" \
    '"assets"'

print_subsection "1.3.2 - Consultas anidadas nivel 2"
run_graphql_test \
    "Portfolio ‚Üí Performance ‚Üí BestPerformer (3 niveles de anidaci√≥n)" \
    "{ portfolio(id: \\\"portfolio-001\\\") { name performance { totalReturn bestPerformer { symbol profitLossPercent } } } }" \
    '"bestPerformer"'

print_subsection "1.3.3 - Uso de variables (parametrizaci√≥n)"
run_test \
    "Query con variable \$id para reutilizaci√≥n y seguridad" \
    "curl -s -X POST ${GRAPHQL_ENDPOINT} -H 'Content-Type: application/json' -d '{\"query\": \"query(\\\$id: ID!) { portfolio(id: \\\$id) { name totalValue } }\", \"variables\": {\"id\": \"portfolio-001\"}}'" \
    '"Growth Portfolio"'

print_subsection "1.3.4 - Variables evitan inyecci√≥n de c√≥digo"
echo -e "${YELLOW}üìù Las variables son validadas autom√°ticamente por GraphQL (tipado fuerte)${NC}"
run_test \
    "Variable de tipo ID! (non-nullable) es validada" \
    "curl -s -X POST ${GRAPHQL_ENDPOINT} -H 'Content-Type: application/json' -d '{\"query\": \"query(\\\$symbol: String!) { searchAsset(symbol: \\\$symbol) { name } }\", \"variables\": {\"symbol\": \"BTC\"}}'" \
    '"Bitcoin"'

print_subsection "1.3.5 - M√∫ltiples relaciones en una sola query"
run_graphql_test \
    "Obtener portfolio con assets Y performance simult√°neamente" \
    "{ portfolio(id: \\\"portfolio-002\\\") { name assets { symbol } performance { yearReturn } } }" \
    '"Retirement Fund"'

################################################################################
# SECCI√ìN 1.4 - FILTROS, ORDEN Y PAGINACI√ìN
################################################################################
print_section "SECCI√ìN 1.4 ‚Äî FILTROS, ORDEN Y PAGINACI√ìN (30 min)"
echo "Objetivo: Enriquecer consultas con argumentos de filtrado, ordenamiento y paginaci√≥n"

print_subsection "1.4.1 - Filtrado por tipo de activo"
run_graphql_test \
    "Filtrar assets por tipo STOCK" \
    "{ assets(portfolioId: \\\"portfolio-001\\\", filter: {assetType: STOCK}) { edges { node { symbol assetType } } totalCount } }" \
    '"assetType":"STOCK"'

print_subsection "1.4.2 - Filtrado por rango de valores"
run_graphql_test \
    "Filtrar assets con valor mayor a \$5000" \
    "{ assets(portfolioId: \\\"portfolio-001\\\", filter: {minValue: 5000}) { edges { node { symbol totalValue } } totalCount } }" \
    '"totalValue"'

print_subsection "1.4.3 - Ordenamiento descendente"
run_graphql_test \
    "Ordenar assets por valor total (mayor a menor)" \
    "{ assets(portfolioId: \\\"portfolio-001\\\", sort: {field: TOTAL_VALUE, direction: DESC}) { edges { node { symbol totalValue } } } }" \
    '"edges"'

print_subsection "1.4.4 - Ordenamiento por ganancia/p√©rdida"
run_graphql_test \
    "Ordenar assets por profit/loss porcentual" \
    "{ assets(portfolioId: \\\"portfolio-001\\\", sort: {field: PROFIT_LOSS_PERCENT, direction: DESC}) { edges { node { symbol profitLossPercent } } } }" \
    '"profitLossPercent"'

print_subsection "1.4.5 - Paginaci√≥n cursor-based (primera p√°gina)"
run_graphql_test \
    "Obtener primera p√°gina de assets (limit: 2)" \
    "{ assets(portfolioId: \\\"portfolio-001\\\", pagination: {limit: 2}) { edges { node { symbol } cursor } pageInfo { hasNextPage endCursor } totalCount } }" \
    '"pageInfo".*"hasNextPage"'

print_subsection "1.4.6 - Combinaci√≥n: Filtro + Orden + Paginaci√≥n"
run_graphql_test \
    "Stocks ordenados por valor, paginados (query compleja)" \
    "{ assets(portfolioId: \\\"portfolio-001\\\", filter: {assetType: STOCK}, sort: {field: TOTAL_VALUE, direction: DESC}, pagination: {limit: 2}) { edges { node { symbol totalValue } cursor } pageInfo { hasNextPage } totalCount } }" \
    '"totalCount"'

print_subsection "1.4.7 - Validaci√≥n de l√≠mites (evitar abuso)"
echo -e "${YELLOW}üìù El backend limita el n√∫mero de resultados para evitar queries costosas${NC}"
run_graphql_test \
    "Paginaci√≥n con l√≠mite razonable funciona correctamente" \
    "{ assets(portfolioId: \\\"portfolio-001\\\", pagination: {limit: 10}) { edges { node { symbol } } } }" \
    '"edges"'

################################################################################
# SECCI√ìN 1.5 - TIPADO, NULLABILIDAD Y SEGURIDAD
################################################################################
print_section "SECCI√ìN 1.5 ‚Äî TIPADO, NULLABILIDAD Y SEGURIDAD B√ÅSICA (30 min)"
echo "Objetivo: Validaci√≥n autom√°tica, tipos non-nullable y seguridad"

print_subsection "1.5.1 - Validaci√≥n de tipos autom√°tica"
run_graphql_test \
    "Campos con tipo Float! retornan n√∫meros v√°lidos" \
    "{ portfolio(id: \\\"portfolio-001\\\") { totalValue } }" \
    '"totalValue":[0-9]'

print_subsection "1.5.2 - Non-nullable types (!) garantizan presencia"
echo -e "${YELLOW}üìù Campos marcados con ! nunca retornan null (contrato garantizado)${NC}"
run_graphql_test \
    "ID!, String!, Float! siempre tienen valor" \
    "{ portfolio(id: \\\"portfolio-001\\\") { id name totalValue } }" \
    '"id":"portfolio-001".*"name":"Growth Portfolio"'

print_subsection "1.5.3 - Enum validation (solo valores permitidos)"
echo -e "${YELLOW}üìù AssetType solo acepta: STOCK, CRYPTO, ETF, BOND, COMMODITY${NC}"
run_graphql_test \
    "Enum AssetType valida autom√°ticamente los valores" \
    "{ portfolio(id: \\\"portfolio-001\\\") { assets { assetType } } }" \
    '"assetType":"(STOCK|CRYPTO|ETF|BOND|COMMODITY)"'

print_subsection "1.5.4 - Introspection del schema (auto-documentaci√≥n)"
run_graphql_test \
    "GraphQL permite introspecci√≥n para conocer el schema" \
    "{ __schema { types { name } } }" \
    '"__schema"'

print_subsection "1.5.5 - Seguridad: Validaci√≥n de argumentos"
echo -e "${YELLOW}üìù GraphQL valida tipos de argumentos antes de ejecutar la query${NC}"
run_test \
    "Argumento ID! es obligatorio (query sin ID falla)" \
    "curl -s -X POST ${GRAPHQL_ENDPOINT} -H 'Content-Type: application/json' -d '{\"query\": \"{ portfolio { name } }\"}'" \
    'error'

print_subsection "1.5.6 - Estructura de respuesta consistente"
run_graphql_test \
    "Mutations retornan estructura consistente (success, message, data)" \
    "mutation { createPortfolio(input: {name: \\\"Final Test\\\"}) { success message portfolio { id } } }" \
    '"success".*"message"'

################################################################################
# RESUMEN FINAL
################################################################################
print_section "üìä RESUMEN DE RESULTADOS"

echo -e "${CYAN}Total de tests ejecutados: ${TOTAL_TESTS}${NC}"
echo -e "${GREEN}‚úÖ Tests exitosos: ${PASSED_TESTS}${NC}"
echo -e "${RED}‚ùå Tests fallidos: ${FAILED_TESTS}${NC}"
echo ""

if [ $FAILED_TESTS -eq 0 ]; then
    echo -e "${GREEN}üéâ ¬°TODOS LOS TESTS PASARON! El Chapter 01 est√° completo y funcional.${NC}"
    echo ""
    echo -e "${CYAN}Cobertura del temario:${NC}"
    echo -e "  ‚úÖ Secci√≥n 1.1 - REST vs GraphQL"
    echo -e "  ‚úÖ Secci√≥n 1.2 - Componentes base"
    echo -e "  ‚úÖ Secci√≥n 1.3 - Consultas anidadas y variables"
    echo -e "  ‚úÖ Secci√≥n 1.4 - Filtros, orden y paginaci√≥n"
    echo -e "  ‚úÖ Secci√≥n 1.5 - Tipado y seguridad"
    echo ""
    exit 0
else
    echo -e "${RED}‚ö†Ô∏è  Algunos tests fallaron. Revisa el output arriba para m√°s detalles.${NC}"
    echo ""
    exit 1
fi