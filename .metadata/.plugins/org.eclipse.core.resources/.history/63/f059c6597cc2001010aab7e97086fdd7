# ğŸ“š CAPÃTULO 1: FUNDAMENTOS DE GRAPHQL Y CONTEXTO CORPORATIVO

**DuraciÃ³n:** 2.5 horas (5 secciones Ã— 30 min)  
**Objetivo:** Comprender por quÃ© GraphQL existe, quÃ© problemas resuelve y cÃ³mo implementarlo profesionalmente

---

## ğŸ“– ÃNDICE DE CONTENIDOS

1. [SecciÃ³n 1.1 - De REST a GraphQL](#secciÃ³n-11---de-rest-a-graphql)
2. [SecciÃ³n 1.2 - Componentes y lenguaje base](#secciÃ³n-12---componentes-y-lenguaje-base)
3. [SecciÃ³n 1.3 - Consultas anidadas y uso de variables](#secciÃ³n-13---consultas-anidadas-y-uso-de-variables)
4. [SecciÃ³n 1.4 - Filtros, orden y paginaciÃ³n](#secciÃ³n-14---filtros-orden-y-paginaciÃ³n)
5. [SecciÃ³n 1.5 - Tipado, nullabilidad y seguridad bÃ¡sica](#secciÃ³n-15---tipado-nullabilidad-y-seguridad-bÃ¡sica)

---

# SecciÃ³n 1.1 - De REST a GraphQL

**DuraciÃ³n:** 30 minutos

## ğŸ¯ Objetivo

Contextualizar el origen de GraphQL frente a las limitaciones del modelo REST tradicional. Comprender los problemas de **overfetching** y **underfetching** en arquitecturas distribuidas, especialmente en ecosistemas bancarios donde la eficiencia en la comunicaciÃ³n entre microservicios es crÃ­tica.

---

## 1. El Problema con REST en Arquitecturas Distribuidas

### 1.1 Contexto: Arquitectura de Microservicios Bancaria

En un ecosistema bancario moderno (NeoBank), tÃ­picamente encontramos:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Portfolio     â”‚     â”‚     Assets      â”‚     â”‚   Performance   â”‚
â”‚   Service       â”‚â”€â”€â”€â”€â–¶â”‚    Service      â”‚â”€â”€â”€â”€â–¶â”‚    Service      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problema:** Cliente mobile necesita mostrar una vista de portfolio completo con assets y performance.

### 1.2 Overfetching: El Cliente Recibe MÃS de lo Necesario

**DefiniciÃ³n:** El servidor retorna datos que el cliente NO necesita.

**Ejemplo REST:**
```http
GET /api/portfolios
```

**Respuesta (JSON):**
```json
[
  {
    "id": "portfolio-001",
    "name": "Growth Portfolio",
    "ownerId": "user-001",
    "ownerName": "Carlos Mendoza",
    "ownerEmail": "carlos@example.com",        â† NO necesario
    "ownerAddress": "...",                     â† NO necesario
    "createdAt": "2025-01-15",
    "lastModified": "2025-11-15",              â† NO necesario
    "totalValue": 59013.75,
    "assets": [ /* 20 campos por asset */ ],   â† Muchos NO necesarios
    "performance": { /* 15 campos */ },        â† Muchos NO necesarios
    "metadata": { /* ... */ }                  â† NO necesario
  }
]
```

**Problema:**
- Cliente solo necesita `name` y `totalValue`
- Servidor envÃ­a **100+ campos innecesarios**
- **Desperdicio de bandwidth:** ~50KB cuando solo necesitaba ~1KB
- **Latencia:** Parsear JSON gigante es costoso en mobile
- **Costo:** MÃ¡s datos = mÃ¡s dinero en cloud providers

**Impacto en NeoBank:**
- Millones de usuarios en mobile
- Conexiones 3G/4G limitadas
- UX lenta = abandono de usuarios

---

### 1.3 Underfetching: El Cliente Recibe MENOS de lo Necesario

**DefiniciÃ³n:** El cliente necesita hacer MÃšLTIPLES llamadas HTTP para obtener todos los datos relacionados.

**Ejemplo REST:**

**Paso 1:** Obtener portfolio
```http
GET /api/portfolios/portfolio-001
```

**Paso 2:** Obtener assets del portfolio
```http
GET /api/portfolios/portfolio-001/assets
```

**Paso 3:** Obtener performance del portfolio
```http
GET /api/portfolios/portfolio-001/performance
```

**Problema:**
- **3 llamadas HTTP** (3 Ã— round-trip time)
- En red lenta: 3 Ã— 200ms = **600ms de latencia**
- **Waterfall effect:** Una llamada depende de la anterior
- **Complejidad en cliente:** Orquestar mÃºltiples requests
- **Error handling complejo:** Â¿QuÃ© pasa si una falla?

**Diagrama de tiempo:**
```
Cliente                        Servidor
  â”‚                               â”‚
  â”‚â”€â”€â”€â”€â”€â”€ GET /portfolios â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
  â”‚                               â”‚
  â”‚â—€â”€â”€â”€â”€â”€â”€ Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  (200ms)
  â”‚                               â”‚
  â”‚â”€â”€â”€ GET /portfolios/001/assetsâ”€â–¶â”‚
  â”‚                               â”‚
  â”‚â—€â”€â”€â”€â”€â”€â”€ Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  (200ms)
  â”‚                               â”‚
  â”‚â”€â”€ GET /portfolios/001/perf â”€â”€â”€â–¶â”‚
  â”‚                               â”‚
  â”‚â—€â”€â”€â”€â”€â”€â”€ Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  (200ms)
  â”‚                               â”‚
Total: 600ms + procesamiento
```

---

## 2. La SoluciÃ³n: GraphQL

### 2.1 Endpoint Ãšnico

**REST:** MÃºltiples endpoints especializados
```
GET /api/portfolios
GET /api/portfolios/{id}
GET /api/portfolios/{id}/assets
GET /api/portfolios/{id}/performance
POST /api/portfolios
PUT /api/portfolios/{id}
DELETE /api/portfolios/{id}
...
```

**GraphQL:** UN solo endpoint
```
POST /graphql
```

**Ventaja:** Toda la lÃ³gica de consulta estÃ¡ en el cliente, no en URLs del servidor.

---

### 2.2 GraphQL Resuelve Overfetching: El Cliente DECLARA lo que Necesita

**Query GraphQL:**
```graphql
{
  myPortfolios {
    name
    totalValue
  }
}
```

**Respuesta (EXACTAMENTE lo pedido):**
```json
{
  "data": {
    "myPortfolios": [
      {
        "name": "Growth Portfolio",
        "totalValue": 59013.75
      }
    ]
  }
}
```

**Beneficios:**
- âœ… Solo 2 campos retornados
- âœ… ~100 bytes vs ~50KB de REST
- âœ… 500x menos datos transferidos
- âœ… Parsing mÃ¡s rÃ¡pido en cliente
- âœ… Mejor UX (carga mÃ¡s rÃ¡pida)

---

### 2.3 GraphQL Resuelve Underfetching: Una Sola Query para Datos Relacionados

**Query GraphQL (TODO en UNA llamada):**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    totalValue
    assets {
      symbol
      currentPrice
      quantity
    }
    performance {
      totalReturn
      yearReturn
      bestPerformer {
        symbol
        profitLossPercent
      }
    }
  }
}
```

**Resultado:**
- âœ… **1 llamada HTTP** vs 3 de REST
- âœ… ~200ms total vs ~600ms de REST
- âœ… **3x mÃ¡s rÃ¡pido**
- âœ… Datos anidados en una sola respuesta
- âœ… Menor complejidad en cliente

**Diagrama de tiempo:**
```
Cliente                        Servidor
  â”‚                               â”‚
  â”‚â”€â”€â”€â”€â”€â”€ POST /graphql â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
  â”‚  (query con portfolio,         â”‚
  â”‚   assets y performance)        â”‚
  â”‚                               â”‚
  â”‚â—€â”€â”€â”€â”€â”€â”€ Response completa â”€â”€â”€â”€â”€â”‚  (200ms)
  â”‚                               â”‚
Total: 200ms + procesamiento
```

---

### 2.4 Declarativo vs Imperativo

**REST (Imperativo):**
El servidor decide quÃ© datos devolver basado en la URL.

```javascript
// Cliente RECIBE lo que el servidor decidiÃ³
const response = await fetch('/api/portfolios');
// No puedo elegir quÃ© campos recibir
```

**GraphQL (Declarativo):**
El cliente DECLARA exactamente lo que necesita.

```graphql
# Cliente PIDE solo lo que necesita
{
  myPortfolios {
    name        # Solo estos 2 campos
    totalValue  # Nada mÃ¡s
  }
}
```

**AnalogÃ­a:**
- **REST:** Como un menÃº de restaurante fijo (recibes lo que estÃ¡ en el combo)
- **GraphQL:** Como un buffet (eliges exactamente lo que quieres)

---

## 3. Ventajas Adicionales de GraphQL

### 3.1 ReducciÃ³n de TrÃ¡fico de Red

**Caso real NeoBank:**
- 1 millÃ³n de requests diarios
- REST: 50KB promedio por request
- GraphQL: 5KB promedio por request

**Ahorro:**
```
REST:    1M Ã— 50KB = 50GB/dÃ­a
GraphQL: 1M Ã— 5KB  = 5GB/dÃ­a
Ahorro:  45GB/dÃ­a  = 1.35TB/mes
```

**Costo en AWS:**
- ~$120 USD/mes de ahorro en bandwidth
- ~$1,440 USD/aÃ±o

### 3.2 SimplificaciÃ³n de Contratos

**REST:**
```
Backend Dev: "Necesito crear 7 endpoints nuevos para mobile"
Frontend Dev: "Â¿CuÃ¡ndo estarÃ¡n listos?"
Backend Dev: "2 semanas..."
Frontend Dev: "Pero necesito 2 campos mÃ¡s en /portfolios"
Backend Dev: "Eso rompe backward compatibility... versiÃ³n 2 de la API"
```

**GraphQL:**
```
Backend Dev: "El schema estÃ¡ publicado, pide lo que necesites"
Frontend Dev: "Genial, agrego 2 campos a mi query"
Backend Dev: "Ya funciona. Sin cambios en mi lado"
```

### 3.3 Mantenibilidad del Backend

**REST:** ProliferaciÃ³n de endpoints
```
/api/v1/portfolios
/api/v1/portfolios/summary           â† mobile
/api/v1/portfolios/full              â† web
/api/v1/portfolios/dashboard         â† tablet
/api/v1/portfolios/export            â† reporting
...
```

**GraphQL:** Un schema, mÃºltiples clientes
```graphql
type Portfolio {
  # Todos los campos disponibles
  # Cada cliente pide lo que necesita
}
```

---

## 4. ComparaciÃ³n REST vs GraphQL

### 4.1 Tabla Comparativa

| Aspecto | REST | GraphQL |
|---------|------|---------|
| **Endpoints** | MÃºltiples (`/users`, `/posts`, etc.) | Uno solo (`/graphql`) |
| **Overfetching** | âŒ ComÃºn (servidor decide campos) | âœ… Eliminado (cliente decide) |
| **Underfetching** | âŒ ComÃºn (mÃºltiples requests) | âœ… Eliminado (una query) |
| **Versioning** | âŒ Necesario (`/api/v1`, `/api/v2`) | âœ… No necesario (campos deprecated) |
| **DocumentaciÃ³n** | âš ï¸ Manual (Swagger, etc.) | âœ… Auto-generada (introspection) |
| **Type Safety** | âš ï¸ Depende (TypeScript, etc.) | âœ… Built-in (schema types) |
| **Caching** | âœ… HTTP cache funciona bien | âš ï¸ MÃ¡s complejo (pero solucionable) |
| **Curva de aprendizaje** | âœ… Baja (HTTP estÃ¡ndar) | âš ï¸ Media (nuevo paradigma) |

### 4.2 CuÃ¡ndo Usar REST vs GraphQL

**Usar REST cuando:**
- âœ… API pÃºblica simple con pocos endpoints
- âœ… CRUD bÃ¡sico sin relaciones complejas
- âœ… Caching HTTP es crÃ­tico
- âœ… Equipo sin experiencia en GraphQL

**Usar GraphQL cuando:**
- âœ… MÃºltiples clientes con necesidades diferentes (mobile, web, tablet)
- âœ… Datos altamente relacionados (grafos)
- âœ… Necesitas flexibilidad sin versionar API
- âœ… Arquitectura de microservicios
- âœ… Performance de red es crÃ­tica

---

## 5. Ejemplos Comparativos (NeoBank)

### Ejemplo 1: Vista de Portfolio Simple

**Necesidad:** Mostrar solo nombre y valor total.

**REST:**
```http
GET /api/portfolios

Response: 50KB (todo el objeto Portfolio)
```

**GraphQL:**
```graphql
{
  myPortfolios {
    name
    totalValue
  }
}

Response: 0.5KB (solo lo pedido)
```

**Resultado:** 100x menos datos.

---

### Ejemplo 2: Vista de Portfolio Completo

**Necesidad:** Portfolio + Assets + Performance.

**REST:**
```http
1. GET /api/portfolios/portfolio-001       (200ms)
2. GET /api/portfolios/portfolio-001/assets (200ms)
3. GET /api/portfolios/portfolio-001/performance (200ms)

Total: 600ms + 3 requests
```

**GraphQL:**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    assets { symbol price }
    performance { totalReturn }
  }
}

Total: 200ms + 1 request
```

**Resultado:** 3x mÃ¡s rÃ¡pido.

---

### Ejemplo 3: Dashboard Personalizado

**Necesidad:** Cada usuario quiere ver diferentes mÃ©tricas.

**REST:**
```http
# Usuario 1: necesita A, B, C
GET /api/dashboard/type1

# Usuario 2: necesita B, D, E
GET /api/dashboard/type2

# Usuario 3: necesita A, D, F
GET /api/dashboard/type3

â†’ Backend mantiene 3+ endpoints
```

**GraphQL:**
```graphql
# Usuario 1
{ portfolio { A B C } }

# Usuario 2
{ portfolio { B D E } }

# Usuario 3
{ portfolio { A D F } }

â†’ Backend mantiene 1 schema
```

**Resultado:** Mantenimiento simplificado.

---

## 6. Conceptos Clave

### 6.1 Endpoint Ãšnico

GraphQL usa **UN solo endpoint HTTP** (tÃ­picamente `/graphql`) para todas las operaciones.

**Por quÃ©:**
- La consulta estÃ¡ en el BODY del request, no en la URL
- El servidor interpreta la query y retorna lo solicitado
- Simplifica routing y versionado

### 6.2 Lenguaje de Consulta

GraphQL es un **lenguaje** para describir quÃ© datos necesitas.

```graphql
# Sintaxis declarativa
{
  portfolio(id: "001") {
    name
    assets {
      symbol
    }
  }
}
```

### 6.3 Schema como Contrato

El **schema** define quÃ© es posible consultar.

```graphql
type Portfolio {
  id: ID!
  name: String!
  totalValue: Float!
  assets: [Asset!]!
}
```

Cliente y servidor comparten este contrato explÃ­cito.

---

## 7. Resumen de SecciÃ³n 1.1

### Problemas de REST que GraphQL resuelve:

1. **Overfetching** â†’ Cliente recibe solo lo que pide
2. **Underfetching** â†’ Una query obtiene datos relacionados
3. **MÃºltiples endpoints** â†’ Un endpoint Ãºnico
4. **Versionado complejo** â†’ Schema evolutivo sin versiones
5. **Contratos implÃ­citos** â†’ Schema explÃ­cito y tipado

### Beneficios clave:

- âœ… **Menos trÃ¡fico de red** (hasta 100x reducciÃ³n)
- âœ… **Menos latencia** (1 request vs mÃºltiples)
- âœ… **Mayor flexibilidad** para clientes
- âœ… **Mejor mantenibilidad** del backend
- âœ… **Desarrollo mÃ¡s rÃ¡pido** (sin esperar nuevos endpoints)

---

# SecciÃ³n 1.2 - Componentes y lenguaje base

**DuraciÃ³n:** 30 minutos

## ğŸ¯ Objetivo

Introducir los cinco pilares del lenguaje GraphQL: **Schema, Types, Queries, Mutations y Resolvers**. Comprender cÃ³mo el schema actÃºa como contrato explÃ­cito entre cliente y servidor, describiendo los tipos disponibles y las operaciones posibles.

---

## 1. Los Cinco Pilares de GraphQL

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           1. SCHEMA                     â”‚
â”‚  (Contrato explÃ­cito)                   â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     2. TYPES                   â”‚    â”‚
â”‚  â”‚  (Portfolio, Asset, etc.)      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 3. QUERIES  â”‚  â”‚ 4. MUTATIONS â”‚    â”‚
â”‚  â”‚  (leer)     â”‚  â”‚  (escribir)  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚     5. RESOLVERS               â”‚    â”‚
â”‚  â”‚  (lÃ³gica de conexiÃ³n)          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Pilar #1: Schema

### 2.1 DefiniciÃ³n

El **schema** es el contrato explÃ­cito que define:
- QuÃ© tipos de datos existen
- QuÃ© operaciones se pueden realizar
- QuÃ© campos tiene cada tipo
- QuÃ© argumentos acepta cada operaciÃ³n

**AnalogÃ­a:** Es como un "API specification" pero mucho mÃ¡s poderoso porque es **ejecutable** y **validable**.

### 2.2 Ejemplo: Schema Investment Portfolio

```graphql
# Archivo: schema.graphqls

# Tipo raÃ­z de queries (lecturas)
type Query {
  # Obtener todos mis portfolios
  myPortfolios: [Portfolio!]!
  
  # Obtener un portfolio especÃ­fico por ID
  portfolio(id: ID!): Portfolio
  
  # Buscar un asset por sÃ­mbolo
  searchAsset(symbol: String!): Asset
}

# Tipo raÃ­z de mutations (escrituras)
type Mutation {
  # Crear un nuevo portfolio
  createPortfolio(input: CreatePortfolioInput!): PortfolioResponse!
  
  # Agregar un asset a un portfolio
  addAsset(input: AddAssetInput!): AssetResponse!
  
  # Remover un asset de un portfolio
  removeAsset(portfolioId: ID!, assetId: ID!): AssetResponse!
}

# Tipo de dominio: Portfolio
type Portfolio {
  id: ID!
  name: String!
  ownerId: ID!
  ownerName: String!
  totalValue: Float!
  createdAt: String!
  assets: [Asset!]!
  performance: Performance!
}

# Tipo de dominio: Asset
type Asset {
  id: ID!
  symbol: String!
  name: String!
  assetType: AssetType!
  quantity: Float!
  averageBuyPrice: Float!
  currentPrice: Float!
  totalValue: Float!
  profitLossPercent: Float!
}

# Tipo de dominio: Performance
type Performance {
  totalReturn: Float!
  yearReturn: Float!
  monthReturn: Float!
  weekReturn: Float!
  bestPerformer: Asset
  worstPerformer: Asset
}

# Enum: Tipos de assets
enum AssetType {
  STOCK
  CRYPTO
  ETF
  BOND
  COMMODITY
}

# Input para crear portfolio
input CreatePortfolioInput {
  name: String!
}

# Input para agregar asset
input AddAssetInput {
  portfolioId: ID!
  symbol: String!
  assetType: AssetType!
  quantity: Float!
  buyPrice: Float!
}

# Response wrapper
type PortfolioResponse {
  success: Boolean!
  message: String!
  portfolio: Portfolio
}

type AssetResponse {
  success: Boolean!
  message: String
}
```

### 2.3 Ventajas del Schema ExplÃ­cito

1. **Auto-documentaciÃ³n:** El schema ES la documentaciÃ³n
2. **ValidaciÃ³n automÃ¡tica:** GraphQL valida queries contra el schema
3. **Type safety:** Los tipos son verificables en tiempo de compilaciÃ³n
4. **Introspection:** El schema es consultable programÃ¡ticamente
5. **Tooling:** IDEs pueden auto-completar basado en el schema

---

## 3. Pilar #2: Types (Tipos)

### 3.1 Tipos Escalares

GraphQL incluye 5 tipos escalares built-in:

```graphql
type Example {
  id: ID              # Identificador Ãºnico (string serializado)
  name: String        # Cadena de texto
  age: Int            # Entero de 32 bits
  price: Float        # NÃºmero de punto flotante
  active: Boolean     # true o false
}
```

### 3.2 Object Types

Tipos personalizados que representan entidades del dominio.

```graphql
type Portfolio {
  id: ID!
  name: String!
  totalValue: Float!
}
```

### 3.3 Non-Nullable (!)

El signo `!` indica que el campo **nunca puede ser null**.

```graphql
type Portfolio {
  id: ID!          # SIEMPRE presente
  name: String!    # SIEMPRE presente
  nickname: String # PUEDE ser null
}
```

**Ejemplo:**
```json
{
  "id": "portfolio-001",        âœ… OK
  "name": "Growth Portfolio",   âœ… OK
  "nickname": null              âœ… OK (es nullable)
}

{
  "id": null,                   âŒ ERROR (debe tener valor)
  "name": "Growth Portfolio"
}
```

### 3.4 Lists (Listas)

```graphql
type Portfolio {
  assets: [Asset!]!
  #       ^^^^^^ ^^
  #       â”‚      â””â”€ La lista nunca es null
  #       â””â”€â”€â”€â”€â”€â”€â”€â”€ Los elementos nunca son null
}
```

**Variaciones:**
```graphql
[Asset]      # Lista nullable con elementos nullable
[Asset]!     # Lista non-null con elementos nullable
[Asset!]     # Lista nullable con elementos non-null
[Asset!]!    # Lista non-null con elementos non-null
```

### 3.5 Enums

Tipos con valores fijos predefinidos.

```graphql
enum AssetType {
  STOCK
  CRYPTO
  ETF
  BOND
  COMMODITY
}

type Asset {
  assetType: AssetType!  # Solo puede ser uno de los 5 valores
}
```

**Ventajas:**
- ValidaciÃ³n automÃ¡tica
- Auto-completado en IDEs
- Type-safe en lenguajes tipados (TypeScript, Java)

### 3.6 Input Types

Tipos especiales para argumentos de queries/mutations.

```graphql
input CreatePortfolioInput {
  name: String!
}

type Mutation {
  createPortfolio(input: CreatePortfolioInput!): PortfolioResponse!
}
```

**Diferencia vs Object Types:**
- `input` solo se usa en argumentos
- `type` solo se usa en retornos

---

## 4. Pilar #3: Queries (Lecturas)

### 4.1 DefiniciÃ³n

Las **queries** son operaciones de **lectura** que obtienen datos del servidor.

```graphql
type Query {
  # Query sin argumentos
  myPortfolios: [Portfolio!]!
  
  # Query con argumento
  portfolio(id: ID!): Portfolio
  
  # Query con mÃºltiples argumentos
  searchAsset(symbol: String!, type: AssetType): Asset
}
```

### 4.2 Sintaxis de una Query

**Query bÃ¡sica:**
```graphql
{
  myPortfolios {
    name
    totalValue
  }
}
```

**Query con argumentos:**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    totalValue
  }
}
```

**Query anidada:**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    assets {
      symbol
      currentPrice
    }
  }
}
```

### 4.3 MÃºltiples Queries en una Request

```graphql
{
  # Query 1
  myPortfolios {
    name
  }
  
  # Query 2
  portfolio(id: "portfolio-001") {
    totalValue
  }
  
  # Query 3
  searchAsset(symbol: "AAPL") {
    currentPrice
  }
}
```

**Resultado:**
```json
{
  "data": {
    "myPortfolios": [...],
    "portfolio": {...},
    "searchAsset": {...}
  }
}
```

---

## 5. Pilar #4: Mutations (Escrituras)

### 5.1 DefiniciÃ³n

Las **mutations** son operaciones de **escritura** que modifican datos en el servidor.

```graphql
type Mutation {
  createPortfolio(input: CreatePortfolioInput!): PortfolioResponse!
  addAsset(input: AddAssetInput!): AssetResponse!
  removeAsset(portfolioId: ID!, assetId: ID!): AssetResponse!
}
```

### 5.2 Sintaxis de una Mutation

**Crear portfolio:**
```graphql
mutation {
  createPortfolio(input: {
    name: "Tech Growth Portfolio"
  }) {
    success
    message
    portfolio {
      id
      name
      totalValue
    }
  }
}
```

**Agregar asset:**
```graphql
mutation {
  addAsset(input: {
    portfolioId: "portfolio-001"
    symbol: "NVDA"
    assetType: STOCK
    quantity: 10
    buyPrice: 500
  }) {
    success
    message
  }
}
```

### 5.3 Response Wrappers

**PatrÃ³n recomendado:** Siempre retornar un wrapper con `success`, `message` y datos opcionales.

```graphql
type PortfolioResponse {
  success: Boolean!     # true si operaciÃ³n exitosa
  message: String!      # Mensaje para el usuario
  portfolio: Portfolio  # Datos solo si success=true
}
```

**Ventajas:**
- Manejo de errores consistente
- UX mejorada (mensajes claros)
- Permite retornar datos parciales

**Ejemplo de uso:**
```graphql
mutation {
  createPortfolio(input: {name: "Test"}) {
    success
    message
    portfolio {
      id
    }
  }
}
```

**Respuesta exitosa:**
```json
{
  "data": {
    "createPortfolio": {
      "success": true,
      "message": "Portfolio created successfully",
      "portfolio": {
        "id": "portfolio-abc123"
      }
    }
  }
}
```

**Respuesta con error:**
```json
{
  "data": {
    "createPortfolio": {
      "success": false,
      "message": "Portfolio name already exists",
      "portfolio": null
    }
  }
}
```

---

## 6. Pilar #5: Resolvers (Conectores)

### 6.1 DefiniciÃ³n

Los **resolvers** son funciones que conectan las queries/mutations del schema con las fuentes de datos (base de datos, microservicios, APIs externas).

**AnalogÃ­a:** Son como "controllers" en REST, pero mÃ¡s granulares (uno por campo si es necesario).

### 6.2 Estructura de un Resolver

```java
@QueryMapping
public List<Portfolio> myPortfolios() {
    // LÃ³gica para obtener portfolios
    return portfolioService.findAllByUser();
}

@QueryMapping
public Portfolio portfolio(@Argument String id) {
    // LÃ³gica para obtener portfolio por ID
    return portfolioService.findById(id);
}

@MutationMapping
public PortfolioResponse createPortfolio(@Argument CreatePortfolioInput input) {
    // LÃ³gica para crear portfolio
    Portfolio portfolio = portfolioService.create(input);
    return new PortfolioResponse(true, "Portfolio created", portfolio);
}
```

### 6.3 Resolvers Anidados

GraphQL permite resolvers para campos individuales dentro de un tipo.

```java
// Resolver de campo: Portfolio.assets
@SchemaMapping(typeName = "Portfolio", field = "assets")
public List<Asset> assets(Portfolio portfolio) {
    return assetService.findByPortfolioId(portfolio.getId());
}

// Resolver de campo: Portfolio.performance
@SchemaMapping(typeName = "Portfolio", field = "performance")
public Performance performance(Portfolio portfolio) {
    return performanceService.calculate(portfolio);
}
```

**Ventaja:** GraphQL solo ejecuta los resolvers de los campos PEDIDOS en la query.

**Ejemplo:**
```graphql
{
  portfolio(id: "001") {
    name        # â† No resolver necesario (campo directo)
    assets {    # â† Ejecuta resolver de assets
      symbol
    }
    # performance NO se pidiÃ³, su resolver NO se ejecuta
  }
}
```

### 6.4 Resolver Chain (Cadena de ResoluciÃ³n)

```
Query
  â””â”€> portfolio(id)              â† Resolver 1: PortfolioQueryResolver
       â””â”€> assets                â† Resolver 2: AssetFieldResolver
            â””â”€> currentPrice     â† Valor directo del objeto Asset
```

---

## 7. Consistencia SemÃ¡ntica

### 7.1 Estructura de Respuesta Refleja Estructura de Query

**Query:**
```graphql
{
  portfolio(id: "001") {
    name
    assets {
      symbol
    }
  }
}
```

**Respuesta (MISMA estructura):**
```json
{
  "data": {
    "portfolio": {
      "name": "Growth Portfolio",
      "assets": [
        {"symbol": "AAPL"},
        {"symbol": "GOOGL"}
      ]
    }
  }
}
```

**Ventaja:** Predecible, fÃ¡cil de parsear, fÃ¡cil de razonar.

### 7.2 Errores vs Datos

GraphQL separa **errores de sistema** de **errores de negocio**.

**Error de sistema:**
```json
{
  "errors": [
    {
      "message": "Field 'invalidField' doesn't exist on type 'Portfolio'",
      "locations": [{"line": 3, "column": 5}]
    }
  ]
}
```

**Error de negocio (en los datos):**
```json
{
  "data": {
    "createPortfolio": {
      "success": false,
      "message": "Name already exists",
      "portfolio": null
    }
  }
}
```

---

## 8. Ejemplo Completo: Portfolio

### 8.1 Schema
```graphql
type Query {
  myPortfolios: [Portfolio!]!
  portfolio(id: ID!): Portfolio
}

type Mutation {
  createPortfolio(input: CreatePortfolioInput!): PortfolioResponse!
}

type Portfolio {
  id: ID!
  name: String!
  totalValue: Float!
  assets: [Asset!]!
}

type Asset {
  symbol: String!
  currentPrice: Float!
}

input CreatePortfolioInput {
  name: String!
}

type PortfolioResponse {
  success: Boolean!
  message: String!
  portfolio: Portfolio
}
```

### 8.2 Query de Ejemplo
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    totalValue
    assets {
      symbol
      currentPrice
    }
  }
}
```

### 8.3 Mutation de Ejemplo
```graphql
mutation {
  createPortfolio(input: {
    name: "New Portfolio"
  }) {
    success
    message
    portfolio {
      id
      name
    }
  }
}
```

### 8.4 Resolvers (Java/Spring)
```java
@Controller
public class PortfolioResolvers {
    
    @Autowired
    private PortfolioService portfolioService;
    
    @QueryMapping
    public List<Portfolio> myPortfolios() {
        return portfolioService.findAll();
    }
    
    @QueryMapping
    public Portfolio portfolio(@Argument String id) {
        return portfolioService.findById(id);
    }
    
    @MutationMapping
    public PortfolioResponse createPortfolio(@Argument CreatePortfolioInput input) {
        Portfolio portfolio = portfolioService.create(input.getName());
        return new PortfolioResponse(true, "Created", portfolio);
    }
    
    @SchemaMapping(typeName = "Portfolio", field = "assets")
    public List<Asset> assets(Portfolio portfolio) {
        return portfolioService.getAssets(portfolio.getId());
    }
}
```

---

## 9. Resumen de SecciÃ³n 1.2

### Los 5 Pilares:

1. **Schema:** Contrato explÃ­cito y ejecutable
2. **Types:** Portfolio, Asset, Performance, etc. (dominio)
3. **Queries:** Operaciones de lectura (`myPortfolios`, `portfolio`)
4. **Mutations:** Operaciones de escritura (`createPortfolio`, `addAsset`)
5. **Resolvers:** LÃ³gica que conecta queries/mutations con datos

### Conceptos clave:

- âœ… El schema ES la documentaciÃ³n
- âœ… Types definen la forma de los datos
- âœ… Queries obtienen, Mutations modifican
- âœ… Resolvers son la "lÃ³gica de conexiÃ³n"
- âœ… La respuesta refleja la estructura de la query

---

# SecciÃ³n 1.3 - Consultas anidadas y uso de variables

**DuraciÃ³n:** 30 minutos

## ğŸ¯ Objetivo

Profundizar en la capacidad de GraphQL para realizar consultas complejas mediante anidaciÃ³n de entidades relacionadas. Introducir el uso de variables en las consultas para mejorar la reusabilidad y evitar inyecciones inseguras.

---

## 1. Consultas Anidadas

### 1.1 El Problema con REST

**Escenario:** Obtener un portfolio con sus assets y el mejor performer.

**REST (3 llamadas):**
```http
1. GET /api/portfolios/portfolio-001
   â†’ Retorna: portfolio bÃ¡sico

2. GET /api/portfolios/portfolio-001/assets
   â†’ Retorna: lista de assets

3. GET /api/portfolios/portfolio-001/performance
   â†’ Retorna: performance con bestPerformer
```

**GraphQL (1 llamada):**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    assets {
      symbol
      currentPrice
    }
    performance {
      totalReturn
      bestPerformer {
        symbol
        profitLossPercent
      }
    }
  }
}
```

### 1.2 AnidaciÃ³n de Nivel 1: Portfolio â†’ Assets

**Query:**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    totalValue
    assets {          # â† Nivel 1 de anidaciÃ³n
      symbol
      currentPrice
      quantity
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "portfolio": {
      "name": "Growth Portfolio",
      "totalValue": 59013.75,
      "assets": [
        {
          "symbol": "AAPL",
          "currentPrice": 185.5,
          "quantity": 10
        },
        {
          "symbol": "GOOGL",
          "currentPrice": 142.3,
          "quantity": 5
        }
      ]
    }
  }
}
```

### 1.3 AnidaciÃ³n de Nivel 2: Portfolio â†’ Performance â†’ BestPerformer

**Query:**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    performance {               # â† Nivel 1
      totalReturn
      yearReturn
      bestPerformer {           # â† Nivel 2
        symbol
        profitLossPercent
        currentPrice
      }
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "portfolio": {
      "name": "Growth Portfolio",
      "performance": {
        "totalReturn": 22.31,
        "yearReturn": 17.85,
        "bestPerformer": {
          "symbol": "BTC",
          "profitLossPercent": 48.88,
          "currentPrice": 67500
        }
      }
    }
  }
}
```

### 1.4 AnidaciÃ³n de Nivel 3: Relaciones MÃºltiples

**Query:**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    owner {                    # â† Nivel 1
      name
      preferences {            # â† Nivel 2
        riskTolerance
        favoriteAssets {       # â† Nivel 3
          symbol
          name
        }
      }
    }
    assets {                   # â† Nivel 1 paralelo
      symbol
      transactions {           # â† Nivel 2 paralelo
        date
        type
        quantity
      }
    }
  }
}
```

**Ventaja:** Una sola query obtiene todo el grafo de relaciones necesarias.

---

## 2. Variables en Queries

### 2.1 El Problema: Hardcoded Values

**Query sin variables (MALA PRÃCTICA):**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
  }
}
```

**Problemas:**
- âŒ No reusable (ID hardcoded)
- âŒ Cada ID requiere una query diferente
- âŒ Riesgo de injection si se concatena string

### 2.2 SoluciÃ³n: Variables Tipadas

**Query con variable (BUENA PRÃCTICA):**
```graphql
query GetPortfolio($id: ID!) {
  portfolio(id: $id) {
    name
    totalValue
  }
}
```

**Variables (JSON separado):**
```json
{
  "id": "portfolio-001"
}
```

**Beneficios:**
- âœ… Reusable (cambias solo las variables)
- âœ… Tipado fuerte (`$id: ID!` valida tipo)
- âœ… Seguro (GraphQL escapa automÃ¡ticamente)
- âœ… Cacheable (query es siempre la misma)

### 2.3 Sintaxis de Variables

**Estructura:**
```graphql
query NombreOperacion($variable: Tipo!) {
  campo(argumento: $variable) {
    ...
  }
}
```

**Elementos:**
- `query`: Tipo de operaciÃ³n (tambiÃ©n puede ser `mutation`)
- `NombreOperacion`: Nombre descriptivo (opcional pero recomendado)
- `$variable`: Nombre de la variable (debe empezar con `$`)
- `Tipo!`: Tipo de la variable (`!` = obligatorio)

### 2.4 Variables MÃºltiples

**Query con mÃºltiples variables:**
```graphql
query SearchAssets(
  $portfolioId: ID!,
  $minValue: Float,
  $assetType: AssetType
) {
  assets(
    portfolioId: $portfolioId,
    filter: {
      minValue: $minValue,
      assetType: $assetType
    }
  ) {
    edges {
      node {
        symbol
        totalValue
      }
    }
  }
}
```

**Variables:**
```json
{
  "portfolioId": "portfolio-001",
  "minValue": 5000,
  "assetType": "STOCK"
}
```

### 2.5 Variables con Defaults

```graphql
query GetPortfolios(
  $limit: Int = 10,           # â† Default: 10
  $sortBy: String = "name"    # â† Default: "name"
) {
  myPortfolios(limit: $limit, sortBy: $sortBy) {
    name
  }
}
```

**Uso sin variables:**
```json
{}  // Usa defaults: limit=10, sortBy="name"
```

**Uso con variables parciales:**
```json
{
  "limit": 5  // Usa limit=5, sortBy="name" (default)
}
```

---

## 3. ValidaciÃ³n AutomÃ¡tica de Variables

### 3.1 ValidaciÃ³n de Tipo

GraphQL valida que las variables coincidan con el tipo declarado.

**Query:**
```graphql
query GetPortfolio($id: ID!) {
  portfolio(id: $id) { name }
}
```

**Variables incorrectas:**
```json
{
  "id": 123  // âŒ ERROR: ID debe ser String
}
```

**Error:**
```json
{
  "errors": [
    {
      "message": "Variable '$id' has invalid value: Expected type 'ID' but got 'Int'"
    }
  ]
}
```

### 3.2 ValidaciÃ³n de Obligatoriedad

**Query con variable obligatoria:**
```graphql
query GetPortfolio($id: ID!) {  # â† ! = obligatorio
  portfolio(id: $id) { name }
}
```

**Variables faltantes:**
```json
{}  // âŒ ERROR: $id es obligatorio
```

**Error:**
```json
{
  "errors": [
    {
      "message": "Variable '$id' of required type 'ID!' was not provided"
    }
  ]
}
```

### 3.3 ValidaciÃ³n de Enums

**Query:**
```graphql
query SearchByType($type: AssetType!) {
  searchAsset(type: $type) { symbol }
}
```

**Variables incorrectas:**
```json
{
  "type": "INVALID_TYPE"  // âŒ ERROR: No estÃ¡ en el enum
}
```

**Error:**
```json
{
  "errors": [
    {
      "message": "Variable '$type' has invalid value: Expected type 'AssetType' but got 'INVALID_TYPE'. Valid values: STOCK, CRYPTO, ETF, BOND, COMMODITY"
    }
  ]
}
```

---

## 4. Argumentos DinÃ¡micos y Consultas Parametrizadas

### 4.1 Reusabilidad

**Escenario:** App mÃ³vil necesita obtener portfolios de diferentes usuarios.

**SIN variables (requiere mÃºltiples queries):**
```graphql
# Query para usuario 1
{ portfolio(id: "portfolio-001") { name } }

# Query para usuario 2
{ portfolio(id: "portfolio-002") { name } }

# Query para usuario 3
{ portfolio(id: "portfolio-003") { name } }
```

**CON variables (1 query reutilizable):**
```graphql
query GetPortfolio($id: ID!) {
  portfolio(id: $id) { name }
}
```

**Uso:**
```javascript
// Frontend code
const query = GET_PORTFOLIO_QUERY; // Misma query siempre

// Usuario 1
fetchGraphQL(query, { id: "portfolio-001" });

// Usuario 2
fetchGraphQL(query, { id: "portfolio-002" });

// Usuario 3
fetchGraphQL(query, { id: "portfolio-003" });
```

### 4.2 Seguridad: Anti-Injection

**INSEGURO (concatenaciÃ³n de strings):**
```javascript
// âŒ NUNCA HACER ESTO
const userId = getUserInput();
const query = `
  {
    portfolio(id: "${userId}") { name }
  }
`;
// Riesgo de injection
```

**SEGURO (variables):**
```javascript
// âœ… CORRECTO
const query = `
  query GetPortfolio($id: ID!) {
    portfolio(id: $id) { name }
  }
`;
const variables = { id: getUserInput() };

fetchGraphQL(query, variables);
// GraphQL escapa automÃ¡ticamente
```

---

## 5. Ejemplos PrÃ¡cticos

### Ejemplo 1: Query Anidada Completa

**Necesidad:** Obtener portfolio con todos sus datos relacionados.

**Query:**
```graphql
query GetCompletePortfolio($id: ID!) {
  portfolio(id: $id) {
    # Nivel 0: Portfolio bÃ¡sico
    id
    name
    totalValue
    createdAt
    
    # Nivel 1: Assets
    assets {
      id
      symbol
      name
      assetType
      quantity
      currentPrice
      totalValue
      profitLossPercent
    }
    
    # Nivel 1: Performance
    performance {
      totalReturn
      yearReturn
      monthReturn
      
      # Nivel 2: Best/Worst Performers
      bestPerformer {
        symbol
        profitLossPercent
      }
      worstPerformer {
        symbol
        profitLossPercent
      }
    }
  }
}
```

**Variables:**
```json
{
  "id": "portfolio-001"
}
```

---

### Ejemplo 2: MÃºltiples Relaciones Paralelas

**Query:**
```graphql
query GetUserData($userId: ID!) {
  user(id: $userId) {
    name
    email
    
    # RelaciÃ³n 1: Portfolios
    portfolios {
      name
      totalValue
    }
    
    # RelaciÃ³n 2: Transactions
    transactions(limit: 10) {
      date
      type
      amount
    }
    
    # RelaciÃ³n 3: Preferences
    preferences {
      riskTolerance
      notifications
    }
  }
}
```

---

### Ejemplo 3: Variables con Input Objects

**Schema:**
```graphql
input AssetFilterInput {
  assetType: AssetType
  minValue: Float
  maxValue: Float
}

type Query {
  assets(
    portfolioId: ID!,
    filter: AssetFilterInput
  ): AssetConnection!
}
```

**Query:**
```graphql
query FilterAssets(
  $portfolioId: ID!,
  $filter: AssetFilterInput
) {
  assets(portfolioId: $portfolioId, filter: $filter) {
    totalCount
    edges {
      node {
        symbol
        totalValue
      }
    }
  }
}
```

**Variables:**
```json
{
  "portfolioId": "portfolio-001",
  "filter": {
    "assetType": "STOCK",
    "minValue": 5000,
    "maxValue": 50000
  }
}
```

---

## 6. Contextos de MÃºltiples Consumidores

### 6.1 Escenario: Mobile, Web y Tablet

**Mismo backend, diferentes necesidades:**

**Mobile (conexiÃ³n lenta):**
```graphql
query GetPortfolioMobile($id: ID!) {
  portfolio(id: $id) {
    name
    totalValue  # Solo lo esencial
  }
}
```

**Web (mÃ¡s detalles):**
```graphql
query GetPortfolioWeb($id: ID!) {
  portfolio(id: $id) {
    name
    totalValue
    createdAt
    assets {
      symbol
      currentPrice
    }
  }
}
```

**Tablet (vista completa):**
```graphql
query GetPortfolioTablet($id: ID!) {
  portfolio(id: $id) {
    name
    totalValue
    createdAt
    assets {
      symbol
      name
      currentPrice
      quantity
      profitLossPercent
    }
    performance {
      totalReturn
      yearReturn
    }
  }
}
```

**Ventaja:** UN backend sirve a TRES clientes con necesidades diferentes.

---

## 7. Resumen de SecciÃ³n 1.3

### AnidaciÃ³n de consultas:

- âœ… Obtener relaciones en UNA query
- âœ… Niveles mÃºltiples: Portfolio â†’ Performance â†’ BestPerformer
- âœ… Relaciones paralelas en una sola llamada
- âœ… Reduce latencia (1 request vs mÃºltiples)

### Variables:

- âœ… **Reusabilidad:** Misma query, diferentes valores
- âœ… **Tipado fuerte:** `$id: ID!` valida automÃ¡ticamente
- âœ… **Seguridad:** Anti-injection built-in
- âœ… **Flexibilidad:** MÃºltiples variables, defaults opcionales

### Conceptos clave:

- ğŸ”¹ Variables mejoran reusabilidad y evitan inyecciones
- ğŸ”¹ GraphQL valida tipos de variables automÃ¡ticamente
- ğŸ”¹ AnidaciÃ³n permite obtener grafos completos
- ğŸ”¹ Un mismo schema sirve a mÃºltiples clientes con necesidades diferentes

---

# SecciÃ³n 1.4 - Filtros, orden y paginaciÃ³n

**DuraciÃ³n:** 30 minutos

## ğŸ¯ Objetivo

Abordar cÃ³mo GraphQL permite enriquecer las consultas mediante argumentos que definen criterios de filtrado, ordenamiento y paginaciÃ³n. Revisar ejemplos de `filter`, `orderBy`, `limit` y `offset`, asÃ­ como el uso del modelo **cursor-based pagination** para aplicaciones que manejan grandes volÃºmenes de datos.

---

## 1. El Problema: Datasets Grandes

### 1.1 Escenario Real

**NeoBank tiene:**
- 1 millÃ³n de usuarios
- Cada usuario tiene 1-100 portfolios
- Cada portfolio tiene 1-1000 assets

**Problema:** Â¿CÃ³mo obtener "los 10 assets mÃ¡s rentables de tipo STOCK con valor > $5000"?

**REST tradicional:**
```http
GET /api/assets?portfolioId=001&type=STOCK&minValue=5000&sort=profitLoss&order=desc&limit=10
```

**Problemas:**
- âŒ URL compleja y frÃ¡gil
- âŒ Cada combinaciÃ³n requiere endpoint especÃ­fico
- âŒ PaginaciÃ³n inconsistente (offset-based tiene problemas)

---

## 2. Filtrado en GraphQL

### 2.1 DefiniciÃ³n de Filtros en Schema

```graphql
input AssetFilterInput {
  assetType: AssetType       # Filtrar por tipo
  minValue: Float            # Valor mÃ­nimo
  maxValue: Float            # Valor mÃ¡ximo
  symbols: [String!]         # Lista de sÃ­mbolos especÃ­ficos
}

type Query {
  assets(
    portfolioId: ID!,
    filter: AssetFilterInput   # â† Argumento de filtro
  ): AssetConnection!
}
```

### 2.2 Query con Filtro Simple

**Filtrar solo STOCKS:**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    filter: {
      assetType: STOCK
    }
  ) {
    totalCount
    edges {
      node {
        symbol
        assetType
      }
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "assets": {
      "totalCount": 2,
      "edges": [
        { "node": { "symbol": "AAPL", "assetType": "STOCK" } },
        { "node": { "symbol": "GOOGL", "assetType": "STOCK" } }
      ]
    }
  }
}
```

### 2.3 Filtros MÃºltiples

**Filtrar STOCKS con valor > $5000:**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    filter: {
      assetType: STOCK,
      minValue: 5000
    }
  ) {
    totalCount
    edges {
      node {
        symbol
        totalValue
      }
    }
  }
}
```

### 2.4 Filtros con Rangos

**Assets entre $5000 y $20000:**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    filter: {
      minValue: 5000,
      maxValue: 20000
    }
  ) {
    totalCount
    edges {
      node {
        symbol
        totalValue
      }
    }
  }
}
```

### 2.5 Filtros con Listas

**Solo AAPL, GOOGL y MSFT:**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    filter: {
      symbols: ["AAPL", "GOOGL", "MSFT"]
    }
  ) {
    totalCount
    edges {
      node {
        symbol
      }
    }
  }
}
```

---

## 3. Ordenamiento en GraphQL

### 3.1 DefiniciÃ³n de Ordenamiento en Schema

```graphql
enum AssetSortField {
  SYMBOL
  CURRENT_PRICE
  TOTAL_VALUE
  PROFIT_LOSS_PERCENT
  QUANTITY
}

enum SortDirection {
  ASC
  DESC
}

input AssetSortInput {
  field: AssetSortField!
  direction: SortDirection!
}

type Query {
  assets(
    portfolioId: ID!,
    filter: AssetFilterInput,
    sort: AssetSortInput        # â† Argumento de ordenamiento
  ): AssetConnection!
}
```

### 3.2 Query con Ordenamiento

**Ordenar por valor total (mayor primero):**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    sort: {
      field: TOTAL_VALUE,
      direction: DESC
    }
  ) {
    edges {
      node {
        symbol
        totalValue
      }
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "assets": {
      "edges": [
        { "node": { "symbol": "BTC", "totalValue": 67500 } },
        { "node": { "symbol": "GOOGL", "totalValue": 7115 } },
        { "node": { "symbol": "VOO", "totalValue": 5888 } },
        { "node": { "symbol": "AAPL", "totalValue": 1855 } }
      ]
    }
  }
}
```

### 3.3 Ordenar por Ganancia/PÃ©rdida

**Mejor performance primero:**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    sort: {
      field: PROFIT_LOSS_PERCENT,
      direction: DESC
    }
  ) {
    edges {
      node {
        symbol
        profitLossPercent
      }
    }
  }
}
```

---

## 4. PaginaciÃ³n en GraphQL

### 4.1 Problema con Offset-Based Pagination

**REST tradicional:**
```http
GET /api/assets?limit=10&offset=0   # PÃ¡gina 1
GET /api/assets?limit=10&offset=10  # PÃ¡gina 2
```

**Problemas:**
- âŒ **Datos duplicados:** Si se insertan items entre pÃ¡ginas
- âŒ **Datos faltantes:** Si se borran items entre pÃ¡ginas
- âŒ **Ineficiente en DB:** OFFSET requiere escanear todos los rows previos

**Ejemplo del problema:**
```
PÃ¡gina 1 (offset=0, limit=10): Items 1-10
[Se inserta nuevo item al principio]
PÃ¡gina 2 (offset=10, limit=10): Items 11-20
â†’ Â¡El item #10 aparece dos veces!
```

### 4.2 SoluciÃ³n: Cursor-Based Pagination

GraphQL recomienda **cursor-based pagination** (paginaciÃ³n basada en cursores).

**Concepto:**
- Cada item tiene un **cursor** Ãºnico (ej: ID codificado en Base64)
- Pides "N items DESPUÃ‰S de este cursor"
- Garantiza consistencia incluso si los datos cambian

### 4.3 Relay Cursor Connections Specification

GraphQL sigue el estÃ¡ndar de **Relay** para paginaciÃ³n:

```graphql
type AssetConnection {
  totalCount: Int!               # Total de items
  edges: [AssetEdge!]!           # Lista de edges
  pageInfo: PageInfo!            # InformaciÃ³n de paginaciÃ³n
}

type AssetEdge {
  node: Asset!                   # El asset en sÃ­
  cursor: String!                # Cursor Ãºnico de este asset
}

type PageInfo {
  hasNextPage: Boolean!          # Â¿Hay mÃ¡s pÃ¡ginas?
  hasPreviousPage: Boolean!      # Â¿Hay pÃ¡ginas anteriores?
  startCursor: String            # Cursor del primer item
  endCursor: String              # Cursor del Ãºltimo item
}
```

### 4.4 Query de PaginaciÃ³n

**Primera pÃ¡gina (primeros 10 items):**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    pagination: {
      first: 10
    }
  ) {
    totalCount
    pageInfo {
      hasNextPage
      endCursor
    }
    edges {
      cursor
      node {
        symbol
        totalValue
      }
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "assets": {
      "totalCount": 42,
      "pageInfo": {
        "hasNextPage": true,
        "endCursor": "YXNzZXQtMDEw"
      },
      "edges": [
        {
          "cursor": "YXNzZXQtMDAx",
          "node": { "symbol": "AAPL", "totalValue": 1855 }
        },
        // ... 9 more
      ]
    }
  }
}
```

**Segunda pÃ¡gina (usando cursor de la primera):**
```graphql
{
  assets(
    portfolioId: "portfolio-001",
    pagination: {
      first: 10,
      after: "YXNzZXQtMDEw"  # â† Cursor del Ãºltimo item
    }
  ) {
    pageInfo {
      hasNextPage
      endCursor
    }
    edges {
      cursor
      node {
        symbol
      }
    }
  }
}
```

### 4.5 Ventajas de Cursor-Based Pagination

âœ… **Consistente:** No se duplican/pierden items  
âœ… **Performante:** No requiere OFFSET costoso  
âœ… **Escalable:** Funciona con datasets de millones de registros  
âœ… **Bi-direccional:** Puedes paginar hacia adelante (`after`) o atrÃ¡s (`before`)  

---

## 5. Combinando Filtro + Orden + PaginaciÃ³n

### 5.1 Query Compleja

**Necesidad:** Los 10 STOCKS mÃ¡s rentables con valor > $5000.

```graphql
{
  assets(
    portfolioId: "portfolio-001",
    filter: {
      assetType: STOCK,
      minValue: 5000
    },
    sort: {
      field: PROFIT_LOSS_PERCENT,
      direction: DESC
    },
    pagination: {
      first: 10
    }
  ) {
    totalCount
    pageInfo {
      hasNextPage
    }
    edges {
      node {
        symbol
        totalValue
        profitLossPercent
      }
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "assets": {
      "totalCount": 2,
      "pageInfo": {
        "hasNextPage": false
      },
      "edges": [
        {
          "node": {
            "symbol": "GOOGL",
            "totalValue": 7115,
            "profitLossPercent": 23.67
          }
        },
        {
          "node": {
            "symbol": "VOO",
            "totalValue": 5888,
            "profitLossPercent": 11.31
          }
        }
      ]
    }
  }
}
```

---

## 6. LÃ­mites y Validaciones del Backend

### 6.1 PrevenciÃ³n de Queries Costosas

**Problema:** Cliente pide 1 millÃ³n de items.

```graphql
{
  assets(pagination: { first: 1000000 }) {  # âŒ Peligroso
    edges { node { symbol } }
  }
}
```

**SoluciÃ³n:** Backend impone lÃ­mites.

```java
@QueryMapping
public AssetConnection assets(
    @Argument String portfolioId,
    @Argument PaginationInput pagination
) {
    // Validar lÃ­mite mÃ¡ximo
    int limit = pagination.getFirst();
    if (limit > 100) {
        throw new GraphQLException("Maximum limit is 100");
    }
    
    // Continuar con la query...
}
```

### 6.2 LÃ­mites Recomendados

```graphql
input PaginationInput {
  first: Int      # MÃ¡ximo recomendado: 100
  after: String
}
```

**Estrategia:**
- Mobile: `first: 10` (pantalla pequeÃ±a)
- Web: `first: 25` (balance)
- Admin: `first: 50` (mÃ¡s contexto)
- **Nunca mÃ¡s de 100 items por pÃ¡gina**

---

## 7. Manejo Eficiente de Resolvers

### 7.1 Resolver con Filtrado

```java
@QueryMapping
public AssetConnection assets(
    @Argument String portfolioId,
    @Argument AssetFilterInput filter,
    @Argument AssetSortInput sort,
    @Argument PaginationInput pagination
) {
    // 1. Obtener assets del portfolio
    List<Asset> assets = assetRepository.findByPortfolioId(portfolioId);
    
    // 2. Aplicar filtros
    if (filter != null) {
        if (filter.getAssetType() != null) {
            assets = assets.stream()
                .filter(a -> a.getAssetType() == filter.getAssetType())
                .collect(Collectors.toList());
        }
        
        if (filter.getMinValue() != null) {
            assets = assets.stream()
                .filter(a -> a.getTotalValue() >= filter.getMinValue())
                .collect(Collectors.toList());
        }
    }
    
    // 3. Aplicar ordenamiento
    if (sort != null) {
        Comparator<Asset> comparator = getComparator(sort.getField());
        if (sort.getDirection() == SortDirection.DESC) {
            comparator = comparator.reversed();
        }
        assets.sort(comparator);
    }
    
    // 4. Aplicar paginaciÃ³n
    int totalCount = assets.size();
    int limit = pagination.getFirst();
    List<Asset> page = assets.stream()
        .limit(limit)
        .collect(Collectors.toList());
    
    // 5. Construir connection
    return new AssetConnection(totalCount, page, hasNextPage);
}
```

### 7.2 OptimizaciÃ³n con DB Queries

**MEJOR PRÃCTICA:** Delegar a la base de datos.

```java
@QueryMapping
public AssetConnection assets(
    @Argument String portfolioId,
    @Argument AssetFilterInput filter,
    @Argument AssetSortInput sort,
    @Argument PaginationInput pagination
) {
    // Construir query dinÃ¡mica en DB
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Asset> query = cb.createQuery(Asset.class);
    Root<Asset> root = query.from(Asset.class);
    
    // WHERE portfolio_id = ?
    Predicate predicate = cb.equal(root.get("portfolioId"), portfolioId);
    
    // AND asset_type = ? (si filter.assetType presente)
    if (filter != null && filter.getAssetType() != null) {
        predicate = cb.and(predicate, 
            cb.equal(root.get("assetType"), filter.getAssetType()));
    }
    
    // ORDER BY total_value DESC
    if (sort != null) {
        Order order = sort.getDirection() == SortDirection.ASC
            ? cb.asc(root.get(sort.getField()))
            : cb.desc(root.get(sort.getField()));
        query.orderBy(order);
    }
    
    query.where(predicate);
    
    // LIMIT 10
    List<Asset> results = entityManager.createQuery(query)
        .setMaxResults(pagination.getFirst())
        .getResultList();
    
    return new AssetConnection(results);
}
```

---

## 8. Resumen de SecciÃ³n 1.4

### Filtrado:

- âœ… `filter: { assetType: STOCK, minValue: 5000 }`
- âœ… MÃºltiples criterios combinables
- âœ… Rangos, listas, valores exactos

### Ordenamiento:

- âœ… `sort: { field: TOTAL_VALUE, direction: DESC }`
- âœ… Ordenar por cualquier campo del schema
- âœ… ASC o DESC

### PaginaciÃ³n:

- âœ… **Cursor-based** mejor que offset-based
- âœ… `first: 10, after: "cursor"`
- âœ… `PageInfo` con `hasNextPage`, `endCursor`
- âœ… Consistente incluso si datos cambian

### LÃ­mites del backend:

- âœ… MÃ¡ximo 100 items por pÃ¡gina
- âœ… ValidaciÃ³n automÃ¡tica en resolvers
- âœ… PrevenciÃ³n de queries costosas

### CombinaciÃ³n:

- âœ… Filtro + Orden + PaginaciÃ³n en UNA query
- âœ… Backend optimiza con DB queries
- âœ… Flexibilidad sin mÃºltiples endpoints

---

# SecciÃ³n 1.5 - Tipado, nullabilidad y seguridad bÃ¡sica

**DuraciÃ³n:** 30 minutos

## ğŸ¯ Objetivo

Introducir el concepto de **tipado fuerte** que caracteriza a GraphQL. Analizar cÃ³mo la validaciÃ³n de tipos evita solicitudes invÃ¡lidas antes de que lleguen al backend, reduciendo la carga operativa y los errores de integraciÃ³n. Explicar los modificadores de **nullabilidad** (`!`) y su impacto en la robustez del contrato. Presentar nociones bÃ¡sicas de seguridad: cÃ³mo propagar credenciales mediante headers (JWT, API Keys) y cÃ³mo restringir el acceso a campos o resolvers a travÃ©s del contexto del servidor.

---

## 1. Tipado Fuerte en GraphQL

### 1.1 Â¿QuÃ© es Tipado Fuerte?

**DefiniciÃ³n:** Cada campo, argumento y variable tiene un **tipo explÃ­cito** que GraphQL valida ANTES de ejecutar la query.

**ComparaciÃ³n:**

**REST (sin tipado):**
```http
GET /api/portfolio?id=abc123&value=not-a-number

â†’ Servidor recibe request
â†’ Procesa hasta fallar en conversiÃ³n
â†’ Error 500 o datos incorrectos
```

**GraphQL (tipado fuerte):**
```graphql
query GetPortfolio($id: ID!, $minValue: Float!) {
  portfolio(id: $id, minValue: $minValue) {
    name
  }
}

Variables: { "id": "abc123", "minValue": "not-a-number" }

â†’ GraphQL RECHAZA antes de ejecutar
â†’ Error claro: "Expected Float, got String"
```

### 1.2 Tipos Escalares

GraphQL valida automÃ¡ticamente los 5 tipos escalares:

```graphql
type Portfolio {
  id: ID              # String Ãºnico
  name: String        # Cadena de texto
  assetCount: Int     # Entero 32-bit
  totalValue: Float   # NÃºmero decimal
  active: Boolean     # true/false
}
```

**Validaciones automÃ¡ticas:**

| Tipo | VÃ¡lido | InvÃ¡lido |
|------|--------|----------|
| `ID` | `"123"`, `"abc"` | `null` (si es `ID!`) |
| `String` | `"Hello"`, `""` | `123` (nÃºmero sin comillas) |
| `Int` | `42`, `-5` | `3.14` (decimal), `"42"` (string) |
| `Float` | `3.14`, `42` | `"3.14"` (string) |
| `Boolean` | `true`, `false` | `"true"` (string), `1` (nÃºmero) |

### 1.3 Ejemplo de ValidaciÃ³n AutomÃ¡tica

**Query:**
```graphql
query GetPortfolio($id: ID!, $minValue: Float!) {
  portfolio(id: $id, minValue: $minValue) {
    name
  }
}
```

**Variables INCORRECTAS:**
```json
{
  "id": 123,                    // âŒ ID debe ser String
  "minValue": "not-a-number"    // âŒ Float debe ser nÃºmero
}
```

**Error (ANTES de ejecutar):**
```json
{
  "errors": [
    {
      "message": "Variable '$id' has invalid value: Expected type 'ID' but got 'Int'",
      "extensions": {
        "classification": "ValidationError"
      }
    },
    {
      "message": "Variable '$minValue' has invalid value: Expected type 'Float' but got 'String'",
      "extensions": {
        "classification": "ValidationError"
      }
    }
  ]
}
```

**Ventaja:** El error se detecta ANTES de tocar la base de datos o ejecutar lÃ³gica de negocio.

---

## 2. Nullabilidad y Modificador `!`

### 2.1 Nullable vs Non-Nullable

**Sin `!` (nullable):**
```graphql
type Portfolio {
  nickname: String    # Puede ser null
}
```

**Con `!` (non-nullable):**
```graphql
type Portfolio {
  name: String!       # NUNCA puede ser null
}
```

### 2.2 GarantÃ­as del Sistema

**Campo non-nullable (`!`):**
- âœ… GraphQL **garantiza** que NUNCA retornarÃ¡ `null`
- âœ… Si el resolver retorna `null`, GraphQL lanza ERROR
- âœ… Cliente puede confiar que el campo siempre tiene valor

**Ejemplo:**
```graphql
type Portfolio {
  id: ID!
  name: String!
  nickname: String    # Opcional
}
```

**Respuesta VÃLIDA:**
```json
{
  "data": {
    "portfolio": {
      "id": "portfolio-001",
      "name": "Growth Portfolio",
      "nickname": null          // âœ… OK (no tiene !)
    }
  }
}
```

**Respuesta INVÃLIDA (causarÃ­a error):**
```json
{
  "data": {
    "portfolio": {
      "id": "portfolio-001",
      "name": null              // âŒ ERROR: name! no puede ser null
    }
  }
}
```

### 2.3 Listas y Nullabilidad

**Variaciones de listas:**

```graphql
type Portfolio {
  # 1. Lista nullable, elementos nullable
  tags: [String]
  # âœ… null | âœ… [] | âœ… ["tag1", null]
  
  # 2. Lista non-null, elementos nullable
  categories: [String]!
  # âŒ null | âœ… [] | âœ… ["cat1", null]
  
  # 3. Lista nullable, elementos non-null
  labels: [String!]
  # âœ… null | âœ… [] | âŒ ["label1", null]
  
  # 4. Lista non-null, elementos non-null
  assets: [Asset!]!
  # âŒ null | âœ… [] | âŒ [asset1, null]
}
```

**Tabla de verdad:**

| DeclaraciÃ³n | `null` | `[]` | `[null]` | `[value]` |
|-------------|--------|------|----------|-----------|
| `[String]` | âœ… | âœ… | âœ… | âœ… |
| `[String]!` | âŒ | âœ… | âœ… | âœ… |
| `[String!]` | âœ… | âœ… | âŒ | âœ… |
| `[String!]!` | âŒ | âœ… | âŒ | âœ… |

### 2.4 Impacto en Robustez del Contrato

**Ventajas de usar `!`:**
- âœ… Elimina `null` checks en cliente
- âœ… TypeScript/Swift/Kotlin generan tipos non-nullable
- âœ… Menos bugs (NullPointerException imposibles)

**Ejemplo TypeScript:**
```typescript
// Sin !
type Portfolio = {
  name: string | null  // Cliente debe validar
}

if (portfolio.name !== null) {
  console.log(portfolio.name.toUpperCase());
}

// Con !
type Portfolio = {
  name: string  // Cliente confÃ­a que existe
}

console.log(portfolio.name.toUpperCase());  // Safe!
```

---

## 3. Enums y ValidaciÃ³n

### 3.1 DefiniciÃ³n de Enums

```graphql
enum AssetType {
  STOCK
  CRYPTO
  ETF
  BOND
  COMMODITY
}

type Asset {
  assetType: AssetType!
}
```

### 3.2 ValidaciÃ³n AutomÃ¡tica

**Query con enum invÃ¡lido:**
```graphql
{
  searchAsset(type: INVALID_TYPE) {  # âŒ No existe en el enum
    symbol
  }
}
```

**Error:**
```json
{
  "errors": [
    {
      "message": "Argument 'type' has invalid value: Expected type 'AssetType', found 'INVALID_TYPE'. Valid values: STOCK, CRYPTO, ETF, BOND, COMMODITY"
    }
  ]
}
```

### 3.3 Ventajas de Enums

- âœ… Valores limitados y validados
- âœ… Auto-completado en GraphiQL
- âœ… Type-safe en cÃ³digo (TypeScript, Java)
- âœ… DocumentaciÃ³n auto-generada

---

## 4. Introspection: Auto-DocumentaciÃ³n

### 4.1 Â¿QuÃ© es Introspection?

**Introspection** permite consultar el schema mismo mediante GraphQL.

**Query de introspection:**
```graphql
{
  __schema {
    types {
      name
      kind
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "__schema": {
      "types": [
        { "name": "Portfolio", "kind": "OBJECT" },
        { "name": "Asset", "kind": "OBJECT" },
        { "name": "AssetType", "kind": "ENUM" },
        { "name": "String", "kind": "SCALAR" },
        ...
      ]
    }
  }
}
```

### 4.2 Consultar Campos de un Tipo

```graphql
{
  __type(name: "Portfolio") {
    name
    fields {
      name
      type {
        name
        kind
      }
    }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "__type": {
      "name": "Portfolio",
      "fields": [
        {
          "name": "id",
          "type": { "name": "ID", "kind": "SCALAR" }
        },
        {
          "name": "name",
          "type": { "name": "String", "kind": "SCALAR" }
        },
        {
          "name": "assets",
          "type": { "name": "Asset", "kind": "OBJECT" }
        }
      ]
    }
  }
}
```

### 4.3 Herramientas que Usan Introspection

- **GraphiQL:** Auto-completado y docs
- **Apollo Client:** Code generation
- **Postman:** Importar schema automÃ¡ticamente
- **GraphQL Code Generator:** Genera TypeScript types

### 4.4 Desactivar Introspection en ProducciÃ³n

**Riesgo:** Introspection expone estructura completa del schema.

**SoluciÃ³n:** Desactivar en producciÃ³n.

```java
@Configuration
public class GraphQLConfig {
    
    @Bean
    public GraphQlSource graphQlSource(Schema schema) {
        return GraphQlSource.schemaResourceBuilder()
            .schemaResources(schema)
            .configureRuntimeWiring(builder -> {
                // Desactivar introspection
                builder.introspectionEnabled(false);
            })
            .build();
    }
}
```

---

## 5. Seguridad BÃ¡sica

### 5.1 AutenticaciÃ³n con JWT

**Flujo:**
```
Cliente                          Servidor GraphQL
  â”‚                                    â”‚
  â”‚â”€â”€ POST /graphql â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
  â”‚   Header: Authorization: Bearer JWT â”‚
  â”‚                                    â”‚
  â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                    â”‚ Validar JWT   â”‚
  â”‚                    â”‚ Extraer userIdâ”‚
  â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                                    â”‚
  â”‚â—€â”€â”€â”€â”€â”€â”€ Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
```

**ImplementaciÃ³n (Spring Boot):**

```java
@Component
public class GraphQLSecurityInterceptor implements WebGraphQlInterceptor {
    
    @Autowired
    private JwtTokenProvider jwtProvider;
    
    @Override
    public Mono<WebGraphQlResponse> intercept(
        WebGraphQlRequest request, 
        Chain chain
    ) {
        // 1. Extraer JWT del header
        String token = extractToken(request);
        
        // 2. Validar JWT
        if (token == null || !jwtProvider.validateToken(token)) {
            throw new GraphQLException("Unauthorized");
        }
        
        // 3. Extraer userId del token
        String userId = jwtProvider.getUserId(token);
        
        // 4. Agregar userId al contexto de GraphQL
        GraphQLContext context = request.toGraphQLContext();
        context.put("userId", userId);
        
        // 5. Continuar con la ejecuciÃ³n
        return chain.next(request);
    }
    
    private String extractToken(WebGraphQlRequest request) {
        String authHeader = request.getHeaders().getFirst("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }
}
```

### 5.2 Uso del Contexto en Resolvers

```java
@QueryMapping
public List<Portfolio> myPortfolios(GraphQLContext context) {
    // Obtener userId del contexto
    String userId = context.get("userId");
    
    // Retornar solo portfolios del usuario autenticado
    return portfolioService.findByUserId(userId);
}
```

### 5.3 AutorizaciÃ³n a Nivel de Campo

**Escenario:** Campo `ownerEmail` solo visible para el dueÃ±o.

```java
@SchemaMapping(typeName = "Portfolio", field = "ownerEmail")
public String ownerEmail(
    Portfolio portfolio,
    GraphQLContext context
) {
    String requestUserId = context.get("userId");
    
    // Verificar que el usuario sea el dueÃ±o
    if (!portfolio.getOwnerId().equals(requestUserId)) {
        throw new GraphQLException("Access denied");
    }
    
    return portfolio.getOwnerEmail();
}
```

**Query:**
```graphql
{
  portfolio(id: "portfolio-001") {
    name
    ownerEmail  # Solo visible para el dueÃ±o
  }
}
```

**Respuesta (si NO eres el dueÃ±o):**
```json
{
  "errors": [
    {
      "message": "Access denied",
      "path": ["portfolio", "ownerEmail"]
    }
  ],
  "data": {
    "portfolio": {
      "name": "Growth Portfolio",
      "ownerEmail": null
    }
  }
}
```

### 5.4 API Keys

**Alternativa a JWT:** API Keys para servicios externos.

```java
@Component
public class ApiKeyInterceptor implements WebGraphQlInterceptor {
    
    @Override
    public Mono<WebGraphQlResponse> intercept(
        WebGraphQlRequest request, 
        Chain chain
    ) {
        String apiKey = request.getHeaders().getFirst("X-API-Key");
        
        if (apiKey == null || !isValidApiKey(apiKey)) {
            throw new GraphQLException("Invalid API Key");
        }
        
        return chain.next(request);
    }
    
    private boolean isValidApiKey(String apiKey) {
        // Validar contra base de datos
        return apiKeyRepository.existsByKey(apiKey);
    }
}
```

---

## 6. Ejemplos de AutenticaciÃ³n y AutorizaciÃ³n

### Ejemplo 1: Solo usuarios autenticados

```java
@QueryMapping
public List<Portfolio> myPortfolios(GraphQLContext context) {
    // Verificar que hay usuario autenticado
    String userId = context.get("userId");
    if (userId == null) {
        throw new GraphQLException("Authentication required");
    }
    
    return portfolioService.findByUserId(userId);
}
```

### Ejemplo 2: Roles y permisos

```java
@MutationMapping
public PortfolioResponse deletePortfolio(
    @Argument String id,
    GraphQLContext context
) {
    String userId = context.get("userId");
    String role = context.get("role");
    
    // Solo ADMIN puede borrar
    if (!"ADMIN".equals(role)) {
        throw new GraphQLException("Admin role required");
    }
    
    portfolioService.delete(id);
    return new PortfolioResponse(true, "Deleted");
}
```

### Ejemplo 3: Rate limiting

```java
@QueryMapping
public List<Asset> assets(
    @Argument String portfolioId,
    GraphQLContext context
) {
    String userId = context.get("userId");
    
    // Verificar rate limit (ej: 100 requests/hora)
    if (!rateLimiter.allowRequest(userId)) {
        throw new GraphQLException("Rate limit exceeded");
    }
    
    return assetService.findByPortfolioId(portfolioId);
}
```

---

## 7. Resumen de SecciÃ³n 1.5

### Tipado Fuerte:

- âœ… **ValidaciÃ³n automÃ¡tica** antes de ejecutar
- âœ… Tipos: `ID`, `String`, `Int`, `Float`, `Boolean`
- âœ… Errores claros: "Expected Float, got String"
- âœ… Reduce carga operativa del backend

### Nullabilidad:

- âœ… `!` = **non-nullable** (nunca null)
- âœ… Sin `!` = **nullable** (puede ser null)
- âœ… GarantÃ­as del sistema: `String!` siempre tiene valor
- âœ… Listas: `[Asset!]!` = lista y elementos non-null

### Enums:

- âœ… Valores predefinidos y validados
- âœ… Auto-completado en IDEs
- âœ… Type-safe en cÃ³digo

### Introspection:

- âœ… Schema consultable programÃ¡ticamente
- âœ… Auto-documentaciÃ³n built-in
- âœ… Herramientas usan introspection
- âš ï¸ Desactivar en producciÃ³n

### Seguridad BÃ¡sica:

- âœ… **JWT:** AutenticaciÃ³n con tokens
- âœ… **Context:** Propagar userId a resolvers
- âœ… **Field-level auth:** Restringir campos especÃ­ficos
- âœ… **API Keys:** Para servicios externos
- âœ… **Rate limiting:** Prevenir abuso

---

# ğŸ“ CONCLUSIÃ“N DEL CAPÃTULO 1

## Lo que Aprendimos

### SecciÃ³n 1.1: REST vs GraphQL
- Problemas de overfetching y underfetching
- Endpoint Ãºnico vs mÃºltiples endpoints
- Declarativo vs imperativo
- ReducciÃ³n de trÃ¡fico y latencia

### SecciÃ³n 1.2: Componentes Base
- Schema como contrato explÃ­cito
- Types, Queries, Mutations, Resolvers
- Consistencia semÃ¡ntica
- Response wrappers

### SecciÃ³n 1.3: AnidaciÃ³n y Variables
- Consultas anidadas multi-nivel
- Variables tipadas y reusables
- ValidaciÃ³n automÃ¡tica
- Seguridad anti-injection

### SecciÃ³n 1.4: Filtros y PaginaciÃ³n
- Filtrado flexible con input types
- Ordenamiento customizable
- Cursor-based pagination
- LÃ­mites del backend

### SecciÃ³n 1.5: Tipado y Seguridad
- Tipado fuerte y validaciÃ³n
- Nullabilidad con `!`
- Introspection
- JWT y field-level authorization


